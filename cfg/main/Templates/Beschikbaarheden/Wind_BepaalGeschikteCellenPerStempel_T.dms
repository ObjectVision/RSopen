template Wind_BepaalGeschikteCellenPerStempel_T
: Descr = "Bepaal geschikte cellen voor windturbines per stempel"
{
	parameter<String> orientatie;
	parameter<UInt32> EersteRijKolomLeeg;
	parameter<meter>  offsetX;
	parameter<meter>  offsetY;
	// end case Parameters
	
	container Impl
	{
		parameter<meter_f64> X_org := reprojectie_windrichting/X_org + offsetX[meter_f64], Descr = "Oorspronkelijke X coordinaat van de linkerbovenhoek van het grid";
		parameter<meter_f64> Y_org := reprojectie_windrichting/Y_org + offsetY[meter_f64], Descr = "Oorspronkelijke Y coordinaat van de linkerbovenhoek van het grid";
	}
	
	container windmolen_grid
	{
		unit<FPoint> coordinatesystem;
		unit<SPoint> GridDomain := range(coordinatesystem, point_xy(0s, 0s), point_yx(reprojectie_windrichting/aantalkolommen, reprojectie_windrichting/aantalrijen))
		, Descr = "Een grid domain zonder relatie met RD coordinaten. Dat komt later pas"
		{
			attribute<Float64>       R                                   := float64(PointCol(id(.)))-2d, Descr = "Column number";
			attribute<Float64>       C                                   := float64(PointRow(id(.)))-2d, Descr = "Row number";
			
			parameter<UInt32>        nr_mogelijke_pos_EersteRijKolomLeeg := ModelParameters/Wind/rijkolom_tussenruimte + ModelParameters/Wind/max_aantal_rijen_zonder_tussenruimte;
			
			attribute<UInt32>        C_mod                               := mod(uint32(C), nr_mogelijke_pos_EersteRijKolomLeeg), Descr = "Column modulo";
			attribute<UInt32>        R_mod                               := mod(uint32(R), nr_mogelijke_pos_EersteRijKolomLeeg), Descr = "Row modulo";
			
			parameter<UInt32>        beginpos_toegestaan                 := EersteRijKolomLeeg;
			parameter<UInt32>        eindpos_toegestaan                  := EersteRijKolomLeeg + ModelParameters/Wind/max_aantal_rijen_zonder_tussenruimte - 1, Descr = "Eindpositie die is toegestaan (inclusief)";
			parameter<Bool>          and_conditie                        := eindpos_toegestaan < nr_mogelijke_pos_EersteRijKolomLeeg, Descr = "Is de eindpositie kleiner dan het aantal mogelijke posities (dan is er geen overlap)";
			
			attribute<Bool>          R_toestaan                          := and_conditie
																			? R_mod >= beginpos_toegestaan && R_mod <= eindpos_toegestaan
																			: R_mod >= beginpos_toegestaan || R_mod <= ((eindpos_toegestaan >= nr_mogelijke_pos_EersteRijKolomLeeg) 
																				? eindpos_toegestaan - min_elem(eindpos_toegestaan, nr_mogelijke_pos_EersteRijKolomLeeg) 
																				: 0), Descr = "Is de rij toegestaan?";
			attribute<Bool>          C_toestaan                          := and_conditie
																			? C_mod >= beginpos_toegestaan && C_mod <= eindpos_toegestaan
																			: C_mod >= beginpos_toegestaan || C_mod <= ((eindpos_toegestaan >= nr_mogelijke_pos_EersteRijKolomLeeg) 
																				? eindpos_toegestaan - min_elem(eindpos_toegestaan, nr_mogelijke_pos_EersteRijKolomLeeg) 
																				: 0), Descr = "Is de kolom toegestaan?";
			
			attribute<UInt32>        id_RC                               := uint32((C) + ((R) * (max(C) + 1d - min(C)))), Descr = "ID gebaseerd op rij en kolom";
			parameter<UInt32>        max_id_RC                           := max(id_RC);
			attribute<meter_f64>     X                                   := reprojectie_windrichting/Xc * C + reprojectie_windrichting/Xr * R, Descr = "x-coord zonder offset";
			attribute<meter_f64>     Y                                   := reprojectie_windrichting/Yc * C + reprojectie_windrichting/Yr * R, Descr = "y-coord zonder offset";
			
			attribute<rdc_meter>     pot_locatie                         := point_yx(Y,X, rdc_meter) + point_yx(impl/Y_org[meter_f64], impl/X_org[meter_f64], rdc_meter), Descr = "Locatie in RDC"
			{
				unit<UInt32> rasterdomaincopy := range(0, #GridDomain)
				{
					attribute<rdc_meter> pl := pot_locatie[point_xy(int16(ID(.) / uint32(reprojectie_windrichting/aantalkolommen)), int16(ID(.) % uint32(reprojectie_windrichting/aantalkolommen)))];
				}
			}
			
			attribute<Bool>          IsStudyArea                         := IsDefined(point_in_polygon(pot_locatie, rdc_meter/geometry));
			attribute<locaties_alle> locaties_alle_rel                   := rlookup(id_RC, id(locaties_alle));
		}
		
		unit<UInt32> locaties_alle := range(uint32, 0, #GridDomain)
		{
			attribute<rdc_meter> geometry := first(GridDomain/pot_locatie, GridDomain/locaties_alle_rel)
			{
				parameter<UInt32> SymbolColor := rgb(200,0,0), DialogType = "SymbolColor";
			}
		}
		
		unit<UInt32> locaties_toegestanerijen := select_with_org_rel(GridDomain/R_toestaan && GridDomain/IsStudyArea)
		, Descr = "Locaties die toegestaan zijn op basis van de rijen en kolommen en binnen het studiegebied"
		{
			attribute<rdc_meter> geometry := GridDomain/pot_locatie[org_rel]
			{
				/* parameter<UInt32> SymbolColor := rgb(0,200,0), DialogType = "SymbolColor"; */
			}
			
			attribute<AdminDomain> in_AdminDomain                := geometry[AdminDomain], Descr = "De admin domain waarin de locatie ligt";
			attribute<Bool>        per_AdminDomain (AdminDomain) := IsDefined(invert(in_AdminDomain)), Descr = "Ligt de locatie in dit admin domain?";
			
			attribute<Bool>        IsBeschikbaar   (AdminDomain) := per_AdminDomain && Subsectoren/Totaal/CompactedAdminDomain/Beschikbaar[invert(CompactedAdminDomain/AdminDomain_rel)], Descr = "Is de locatie beschikbaar voor windturbines";
			parameter<UInt32>      AantalLocaties                := sum(IsBeschikbaar[uint32]), Descr = "Aantal geschikte locaties in dit grid";
		}
	}
}