Template simplifyT
{
	unit<UInt32> Iteratie_domain;
	parameter<UInt32> nrIteRations;
	
	unit<UInt32> Iter := range(Uint32, 0, nrIteRations)
	{
		attribute<String> name := 'I'+string(id(.));
		attribute<Bool>   IsFirstIter := id(.) == 0;
		
		attribute<String> PrevName   := IsFirstIter ? 'StartingState' : name[id(.) - min_elem( id(.), 1)];
		attribute<String> PrevState  := IsFirstIter ? 'StateVoorAllocatie' : PrevName+'/StateNaAllocatie';
	}
	
	container StartingState 
	{
		unit<UInt32> NextValue := sequence2points(Iteratie_domain/geometry);
	}
	
	container Iters := for_each_ne(Iter/name, 'IterT('+Iter/PrevName+', Iteratie_domain)');
	container LastIter := =last('Iters/'+Iter/name);
	
	template IterT
	{
		container PrevIterator;
		unit<UInt32> domain;
		
		unit<UInt32>  PrevValue := PrevIterator/NextValue;
		
		container _ConvexHullT := MakeConvexHullT(domain, PrevValue);
		unit<UInt32>  NextValue := _ConvexHullT/sequence/Convex_hull_points;
	}
	
	container MakeFinal 
	{
		unit<UInt32> Domain_with_endpoints := union_unit(Iteratie_domain, LastIter/NextValue)
		{
			attribute<rdc_meter>  point      := union_data(., LastIter/NextValue/point, first(LastIter/NextValue/point, LastIter/NextValue/Sequence_rel));
			attribute<UInt32>     Sequence_rel := union_data(., LastIter/NextValue/Sequence_rel, id(Iteratie_domain));
		}
		attribute<rdc_meter>  convex_hull (Iteratie_domain, poly) := points2sequence(Domain_with_endpoints/point, Domain_with_endpoints/Sequence_rel);
	}
	
	Template MakeConvexHullT
	{
		//
		unit<UInt32> domain;
		unit<UInt32> seq;
		//
		
		unit<UInt32> sequence := seq
		{
			attribute<rdc_meter> point := seq/point;
			attribute<UInt32> Sequence_rel := seq/Sequence_rel;
			
			attribute<UInt32> min_index (domain) := min_index(id(.), Sequence_rel);
			attribute<UInt32> max_index (domain) := max_index(id(.), Sequence_rel);
			
			attribute<Bool> IsFirst := id(.) == min_index[Sequence_rel];
			attribute<Bool> IsLast  := id(.) == max_index[Sequence_rel];
			attribute<UInt32> prev_id := IsFirst ? rjoin(Sequence_rel, id(domain), max_index) : id(.) - min_elem( id(.), 1);   
			attribute<UInt32> next_id := Islast  ? rjoin(Sequence_rel, id(domain), min_index) : id(.) + 1;
			attribute<rdc_meter> A := point[prev_id];
			attribute<rdc_meter> B := point;
			attribute<rdc_meter> C := point[next_id];
			attribute<rdc_meter> p := B - A;
			attribute<rdc_meter> q := C - B;
			
			attribute<Float64> Px := PointCol(P);
			attribute<Float64> Py := PointRow(P);
			attribute<Float64> Qx := PointCol(Q);
			attribute<Float64> Qy := PointRow(Q);
			
			attribute<Float64> det := Px*Qy - Py*Qx;
			
			unit<UInt32> Convex_hull_points := select_with_org_rel(det <= 0d && (point != rjoin(prev_id, id(.), point)))
			{
				attribute<rdc_meter> point := ../point[org_rel];
				attribute<UInt32> Sequence_rel := ../Sequence_rel[org_rel];
			}
		}
	}
}