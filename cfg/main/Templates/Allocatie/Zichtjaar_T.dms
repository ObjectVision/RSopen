Template Zichtjaar_T
: Descr = "Een zichtjaar binnen een allocatiecasus, met daarin de state voor en na allocatie, en de sequenties om verdringing in latere jaren te kunnen heralloceren."
{
	parameter<String> name;
	container StateVoorAllocatie0;
	container Impl0;
	//
	
	parameter<Jaar> AantalJaren := (rjoin(lowercase(name), lowercase(Time/Zichtjaar/name), Time/Zichtjaar/YearRange_rel) - rjoin(lowercase(name), lowercase(Time/Zichtjaar/name), Time/Zichtjaar/PrevYearRange_rel))[Jaar];
	
	container StateVoorAllocatie := StateVoorAllocatie0
	{
		container Werken0 := 
			for_each_nedv(
				Jobs6/name
				, NOT(/VariantParameters/SectorAllocRegio/Uq_Sectors/HasWerkenSector) //om te kunnen rekenen zonder werken als sectorAllocRegio
					? 'const(0[Job], CompactedAdminDomain)' 
					: 'MakeDefined(StateVoorAllocatie0/Werken/'+Jobs6/name+' / (1f + (VariantParameters/VariantK/'+Jobs6/name+'[VariantParameters/VariantK/V/'+Variant_name+'] * AantalJaren)), 0[job])'
				, CompactedAdminDomain
				, job
			), Descr = "noemer voor verandering door van werkdichtheid (banen/cel) in bestaand gebied. Eenheid is job, maar Impliciet aantal jobs per cell. Dus dichtheid.";
		
		container Werken := Werken0, Descr = "uitkomst in job/m2, factor gaat over groei m2/job. Src=job/m2"
		{
			attribute<job> Zak_dienstverlening (CompactedAdminDomain) :=
				= first(lowercase(Time/Zichtjaar/name)) == lowercase(name) && ModelParameters/werken/Thuiswerk_verdikking_ook_op_bestaandekantoren
					? 'MakeDefined(1f / ((1f / Werken0/Zak_dienstverlening) * (1f + VariantParameters/VariantK/m2BVO_job_Kantoor_groeifactor[VariantParameters/VariantK/V/'+Variant_name+'])), 0[job])'
					: 'Werken0/Zak_dienstverlening', Descr = "Eenmalig ophoging van het aantal kantoorbanen per cel. Het idee erachter is dat je door verdikking meer mensen/banen in een kantoorgebouw kwijt kunt en je minder nieuwe kantoren hoeft te bouwen. Hierdoor krijg je wellicht al overrealisatie voordat de allocatie begint. Maar je hoeft dus geen nieuwe kantoorruimte te creeren.";
		}

		container Wind
		{
			attribute<Bool>  MoetWindmolenAfgebrokenWorden (CompactedAdminDomain) := jaartal_ingebruikname_0 + ModelParameters/Wind/WindmolenAfschrijving < UInt16(right(name, 4)), Descr = "Als de jaartal ingebruikname + afschrijving kleiner is dan het zichtjaar, moet de windmolen worden afgebroken";
			attribute<Yr>    jaartal_ingebruikname_0       (CompactedAdminDomain) := StateVoorAllocatie0/Wind/jaartal_ingebruikname, Descr = "Het jaartal van ingebruikname van de windmolen in het vorige zichtjaar";
			attribute<Yr>    jaartal_ingebruikname         (CompactedAdminDomain) := VariantParameters/SectorAllocRegio/Uq_Sectors/HasWindSector && MoetWindmolenAfgebrokenWorden ? (0/0)[Yr] : jaartal_ingebruikname_0, Descr = "Het jaartal van ingebruikname van de windmolen in dit zichtjaar, of undefined als de windmolen is afgebroken";
			attribute<MW>    Totaal                        (CompactedAdminDomain) := VariantParameters/SectorAllocRegio/Uq_Sectors/HasWindSector && MoetWindmolenAfgebrokenWorden ? 0[MW]     : StateVoorAllocatie0/Wind/Totaal, Descr = "Het totaal vermogen aan windmolens in dit zichtjaar, of 0 als de windmolen is afgebroken";
		}
	}
	
	container Context
	{
		container ThisZichtjaar := ..;
		parameter<String> ThisZichtjaar_name := ../name;
	}
	
	container Sequences :=
		for_each_ne(
			Sequence_later/name
			, 'Sequence_T('
				+string(id(Sequence_later))+'[Sequence_later]'                           // sequence id
				', '+Sequence_later/PrevName+'/StateNaAllocatie'                         // container indicating the prev states
				', Context'                                                              // context folder from previous step
				', FALSE'                                                                // bool whether first sequence
				', CaseClassifications/Actor/SectorAllocRegio/SectorAllocRegio_LaterSeq' // unit with sector alloc regio set
				', Sequence_later'                                                       // unit of single first sequence or later sequences
				', Impl'                                                                 // Impl folder from previous step
			')'
		), Descr = "Sequences zijn nodig om verdrongen wooneenheden, banen etc in een sequentie in een volgende sequentie te heralloceren, voor zover de verdringing restclaims opleverede"
	{
		container Seq_0 := Sequence_T(
			0[Sequence_first]                             // sequence id
			, StateVoorAllocatie                          // container indicating the prev states
			, Context                                     // context folder from previous step
			, TRUE                                        // bool whether first sequence
			, CaseClassifications/Actor/SectorAllocRegio  // unit with sector alloc regio set
			, Sequence_first                              // unit of single first sequence or later sequences
			, Impl                                        // Impl folder from previous step
		), Descr = "Eerste sequentie, die werkt op basis van de state voor allocatie";
		
		container LastSequence := =last(Sequence_later/name)
		{
			container StateNaAllocatie := =last(Sequence_later/name)+'/StateNaAllocatie'; 
		}
	}
	
	
	container Impl := Impl0
	{
		parameter<String>  Generate  := 'Allocatie'+name, ExplicitSuppliers = "=asList('WriteStand/'+StandVar/path, ';')", Descr = "Generate parameter to trigger generation of the stand files for this zichtjaar";

		parameter<Bool>   Ontkoppeld := ='ModelParameters/StandAllocatieOntkoppeld', Descr = "Of de stand allocatie ontkoppeld is van de sector allocatie. Als dat zo is, worden de stand bestanden eerst ingelezen, gecompacteerd, en na de sector allocatie weer teruggeschreven. Als dat niet zo is, worden de stand bestanden direct overschreven.";
		
		unit<UInt32> StandVar := CaseClassifications/StandVar;
		
		container ReadStand_UNCHECKED :=
			for_each_ndvna(
				 StandVar/path
				, AdminDomain
				, StandVar
				, StandVar/unit_name
				, '%LocalDataProjDir%/Allocatie/'+Casus_name +'/Stand'+name+'/'+StandVar/path+'_'+/ModelParameters/StudyArea+'.tif'
			), StorageReadOnly = "True", Descr = "This tif file could potentially contain only zeros or undefined values. To check for this eventuality, the container following this one checks for this.";
		
		container ReadStand :=
			for_each_neidvn(
			// for_each_nedvn(
				 StandVar/path
				, 'ReadStand_UNCHECKED/'+StandVar/path
				, StandVar/IsLandbouw || (NOT(/VariantParameters/SectorAllocRegio/Uq_Sectors/HasWonenSector) && StandVar/name == 'OP_rel') ? '' : 'not(all(IsNull(this))) && not(all(IsZero(this)))'
				, AdminDomain
				, StandVar
				, StandVar/unit_name
			), StorageReadOnly = "True"
		{
			container wonen
			{
				attribute<Woning> Aantal_Woningen_Totaal (AdminDomain) := = 'add('+asItemList(Classifications/Vastgoed/WP2xVSSH/name)+')';
				attribute<Woning> Aantal_Woningen_Totaal_NVM (NVM) := sum(Aantal_Woningen_Totaal, NVM/Per_AdminDomain);
			}
		}

		container ReadStand_Compacted := 
			for_each_nedvn(
				StandVar/path
				, 'collect_by_cond(CompactedAdminDomain, AdminDomain/IsCompactedDomain, ReadStand/'+StandVar/path+')'
				, CompactedAdminDomain
				, StandVar
				, StandVar/unit_name
			), Descr = "Stand bestanden gecompacteerd naar het compacted admin domain, om daarna in het compacted admin domain de sector allocatie uit te voeren.";
			
		container CalcStand_Compacted := 
			for_each_nedvn(
				StandVar/path
				, 'Sequences/LastSequence/StateNaAllocatie/'+StandVar/path
				, CompactedAdminDomain
				, StandVar
				, StandVar/unit_name
			), Descr = "De gealloceerde waarden in het compacted admin domain, na de sector allocatie.";

		container CalcStand := 
			for_each_nedvn(
				StandVar/path
				, 'recollect_by_cond(AdminDomain/IsCompactedDomain, CalcStand_Compacted/'+StandVar/path+', (0 / 0) [scope(StandVar, '+StandVar/unit_name+')])'
				, AdminDomain
				, StandVar
				,StandVar/unit_name
		), Descr = "De gealloceerde waarden terug in het volledige admin domain, met undefined voor de niet gecompacteerde cellen.";
		
		container WriteStand :=
			for_each_neidvnat(
				StandVar/path
				, 'CalcStand/'+StandVar/path
				, StandVar/IsLandbouw || (NOT(/VariantParameters/SectorAllocRegio/Uq_Sectors/HasWonenSector) && StandVar/name == 'OP_rel') ? '' : 'not(all(IsNull(this))) && not(all(IsZero(this)))'
				, AdminDomain
				, StandVar
				, StandVar/unit_name
				, '%LocalDataProjDir%/Allocatie/'+Casus_name +'/Stand'+name+'/'+StandVar/path+'_'+/ModelParameters/StudyArea+'.tif'
				, 'gdalwrite.grid'
			), Descr = "Write the calculated stand file back to a tif file, but only if the stand file is not completely empty or undefined.";
			
		container WriteStand_Compacted := 
			for_each_nedvn(
				StandVar/path
				, 'collect_by_cond(CompactedAdminDomain, AdminDomain/IsCompactedDomain, WriteStand/'+StandVar/path+')'
				, CompactedAdminDomain
				, StandVar
				, StandVar/unit_name
			), Descr = "De gealloceerde waarden in het compacted admin domain, na de sector allocatie, via conversie van Compacted naar Uncompacted zodat het ook weggeschreven wordt.";
	}
	
	container StateNaAllocatie := = Impl/Ontkoppeld ? 'Impl/ReadStand_Compacted' : 'Impl/WriteStand_Compacted';
}