Template SectorAllocRegio_T
: Descr = "Template voor een sector-allocatie regio, waarin een bepaalde sector in een bepaalde regio gealloceerd wordt."
{
	unit<UInt8>                 SectorAllocRegio;
	parameter<SectorAllocRegio> id;
	container                   StateVoorAllocatie;
	container                   Context0;
	parameter<UInt8>            AantalIters;
	container                   Impl;
	//
	
	parameter<String> name            := SectorAllocRegio/name[id];
	parameter<String> Sector_name     := SectorAllocRegio/Sector_name[id];
	parameter<String> AllocRegio_name := SectorAllocRegio/AllocRegio_name[id];
	parameter<String> AllocRegio_path := SectorAllocRegio/AllocRegio_path[id];
	
	unit<UInt32>      AllocRegio                  := =ModelParameters/StudyArea == 'Friesland' ? AllocRegio_path+'/StudyArea' : AllocRegio_path, Descr = "De regio-unit waarin gealloceerd wordt, bijvoorbeeld Friesland of MRA.";
	parameter<String> AllocRegio_StudyArea_orgrel := ModelParameters/StudyArea == 'Friesland' ? '[AllocRegio/org_rel]' : '';
	unit<UInt8>       Subsector                   := = SectorAllocRegio/Subsector_ref[id];
	
	container Context := Context0
	{
		container ThisSectorAllocRegio := ..;
		parameter<String> ThisSectorAllocRegioname := ThisSectorAllocRegio/name;
		parameter<String> Prev_SectorAllocRegio_name := rjoin(lowercase(ThisSectorAllocRegio/name), lowercase(SectorAllocRegio/name), SectorAllocRegio/PrevName);
	}
	
	unit<UInt8> Iter := range(uint8, 0[uint8], AantalIters)
	{
		attribute<String> name := 'Iter_'+string(id(.));
		attribute<Bool>   IsFirstIter := id(.) == 0b;
		
		attribute<String> PrevName   := IsFirstIter ? 'Start' : name[id(.) - min_elem( id(.), 1b)];
		attribute<String> PrevState := IsFirstIter ? 'StateVoorAllocatie' : Iter/PrevName+'/StateNaAllocatie';
		attribute<String> Label := name, DialogType = "LabelText";
	}
	
	container Iters_Normaal :=
		for_each_ne(
			Iter/name,
			'Iter_T(
					'+string(id(Iter))+'[Iter]
					, '+Iter/PrevState+'
					, Context
					, Iter
					, Impl
					, FALSE
				)'
		), Descr = "Iteraties zijn nodig om niet vervulde restclaims in een iteratie in een volgende iteratie te vervullen. "
	{
		container LastIter := =last(Iter/name)
		{
			container OverflowNaLastIter := 
				for_each_nedv(
					Subsector/name  
					, replace(
						'VariantData/Claims/@Z@/SectorAllocRegios/@AS@/@S@'+AllocRegio_StudyArea_orgrel+' - Stand_PerAllocRegio/@SP@',
						'@Z@' , Context/ThisZichtjaar_name,
						'@AS@', Context/ThisSectorAllocRegio/name,
						'@S@' , Subsector/name,
						'@SP@', Subsector/Sector_name_Thisname)
					, AllocRegio
					, Float32
				), StorageName = "='%LocalDataProjDir%/Allocatie/'+Casus_name+'/OverflowNa_'+Context/ThisZichtjaar_name+'_'+Context/ThisSequenceName+'_'+Context/ThisSectorAllocRegioName+'.csv'", StorageType = "gdalwrite.vect"
			{
				attribute<float32> All        (AllocRegio) := ='add('+AsItemList(Subsector/name)+')', ExplicitSuppliers = "Regio_id;Regio_name";
				attribute<string>  Regio_id   (AllocRegio) := string(id(AllocRegio));
				attribute<string>  Regio_name (AllocRegio) := AllocRegio/name;
			}
		}	

	}
	
	container Iters_Enkel 
	: Descr = "Zon en Verblijfsrecreatie hebben niet meerdere iteraties nodig, dus gaan verder in een enkele iteratie." 
	{
		container Iter_0 := = 
			 'Iter_T(
					0[Iter]
					,StateVoorAllocatie
					,Context
					,Iter
					,Impl
					,TRUE
				)';
		
		container LastIter := ='Iter_0'
		{
			container OverflowNaLastIter := 
				for_each_nedv(
					Subsector/name  
					, replace(
						'VariantData/Claims/@Z@/SectorAllocRegios/@AS@/@S@'+AllocRegio_StudyArea_orgrel+' - Stand_PerAllocRegio/@SP@',
						'@Z@' , Context/ThisZichtjaar_name,
						'@AS@', Context/ThisSectorAllocRegio/name,
						'@S@' , Subsector/name,
						'@SP@', Subsector/Sector_name_Thisname)
					, AllocRegio
					, Float32
				), StorageName = "='%LocalDataProjDir%/Allocatie/'+Casus_name+'/OverflowNa_'+Context/ThisZichtjaar_name+'_'+Context/ThisSequenceName+'_'+Context/ThisSectorAllocRegioName+'.csv'", StorageType = "gdalwrite.vect"
			{
				attribute<float32> All        (AllocRegio) := ='add('+AsItemList(Subsector/name)+')', ExplicitSuppliers = "Regio_id;Regio_name";
				attribute<string>  Regio_id   (AllocRegio) := string(id(AllocRegio));
				attribute<string>  Regio_name (AllocRegio) := AllocRegio/name;
			}
		}
		
	}
	container Iters_Landbouw 
	: Descr = "Landbouw gebruiks discrete allocatie, en behoeft dus een ander mechanisme." 
	{
		container Iter_0 := = 
			 'Iter_Landbouw_T(
					0[Iter]
					,StateVoorAllocatie
					,Context
					,Iter
					,Impl
					,TRUE
				)';
		
		container LastIter := ='Iter_0';
	}
	
	parameter<String> Iter_str := lowercase(Sector_name) == lowercase('Zon') ? 'Iters_Enkel' : lowercase(Sector_name) == lowercase('Landbouw') ? 'Iters_Landbouw' : 'Iters_Normaal', Descr = "Welke iteratie container wordt gebruikt, de normale met meerdere iteraties, of de enkele voor zon en verblijfsrecreatie, of de landbouw variant.";
	
	container Iters := =Iter_str
	{
	
		parameter<Bool> HasEnoughIteraties_Normaal := ='Iters_Normaal/'+last(Iter/name)+'/Impl/StopCriterium', Descr = "Is het stopcriterium bereikt in de laatste iteratie?";
		parameter<Bool> HasEnoughIteraties_Enkel   := ='Iters_Enkel/Iter_0/Impl/StopCriterium', Descr = "Is het stopcriterium bereikt in de enkel-iteratie-variant?";
		parameter<Bool> HasEnoughIteraties         := =lowercase(Iter_str) == lowercase('Iters_Enkel') ? 'HasEnoughIteraties_Enkel' : 'HasEnoughIteraties_Normaal', Descr = "Is het stopcriterium bereikt in de juiste iteratie-variant?";
		
		// parameter<Bool> HasNotEnoughIteraties := NOT(HasEnoughIteraties);
	}
	
	#include<Restricties_Dynamisch_Wind.dms> //dynamische restricties tbv nieuwe windallocatie
	
	container RestrictiesVoorSectorenAlsGevolgVanWind 
	{
		attribute<bool>      Restrictief_voor_kwestbare_gebouwen         (CompactedAdminDomain) := IsDefined(collect_by_cond(CompactedAdminDomain, AdminDomain/IsCompactedDomain, poly2grid(WindCellen/kwestbare_gebouwen, AdminDomain)));
		attribute<bool>      Restrictief_voor_beperkt_kwestbare_gebouwen (CompactedAdminDomain) := IsDefined(collect_by_cond(CompactedAdminDomain, AdminDomain/IsCompactedDomain, poly2grid(WindCellen/beperkt_kwestbare_gebouwen, AdminDomain)));
		
		container RelevanteWindContainer := =VariantParameters/SectorAllocRegio/Uq_Sectors/HasWindSector ? 'StateVoorAllocatie/Wind' : '/BaseData/StartState/StateBasisjaar/src/Wind';
		attribute<bool> WindCelSelectConditie (CompactedAdminDomain) := =VariantParameters/SectorAllocRegio/Uq_Sectors/HasWindSector ? 'RelevanteWindContainer/Totaal > 0f' : 'RelevanteWindContainer/Totaal_Compacted > 0f';
		
		unit<uint64> WindCellen := select_with_org_rel(recollect_by_cond(AdminDomain/IsCompactedDomain, WindCelSelectConditie))
		{
			attribute<rdc_meter> geometry          := org_rel[rdc_meter];
			attribute<Meter>     Ashoogte          := =VariantParameters/SectorAllocRegio/Uq_Sectors/HasWindSector ? 'recollect_by_cond(AdminDomain/IsCompactedDomain, RelevanteWindContainer/Ashoogte)[org_rel]' : 'RelevanteWindContainer/Ashoogte[org_rel]';
			attribute<Meter>     Rotordiameter     := =VariantParameters/SectorAllocRegio/Uq_Sectors/HasWindSector ? 'recollect_by_cond(AdminDomain/IsCompactedDomain, RelevanteWindContainer/Rotordiameter)[org_rel]' : 'RelevanteWindContainer/Rotordiameter[org_rel]';
			attribute<Meter>     MaxWerpAfstandNom := =VariantParameters/SectorAllocRegio/Uq_Sectors/HasWindSector ? 'recollect_by_cond(AdminDomain/IsCompactedDomain, RelevanteWindContainer/MaxWerpAfstandNom)[org_rel]' : 'RelevanteWindContainer/MaxWerpAfstandNom[org_rel]';
		
			attribute<float64>   kwestbare_gebouwen_buffer_size         := max_elem(
																				AfstandGeluidsnorm
																				,Ashoogte + 0.5f * RotorDiameter
																				,MaxWerpAfstandNom
																			)[float64];
			attribute<float64>   beperkt_kwestbare_gebouwen_buffer_size := MakeDefined(0.5d * RotorDiameter[float64], 0.5d * Ashoogte[float64]);
			attribute<rdc_meter> kwestbare_gebouwen              (poly) := bg_buffer_point(geometry, kwestbare_gebouwen_buffer_size, 16b), Descr = "Wonen, Buffer rond windturbines obv regels voor kwetsbare gebouwen.";
			attribute<rdc_meter> beperkt_kwestbare_gebouwen      (poly) := bg_buffer_point(geometry, beperkt_kwestbare_gebouwen_buffer_size, 16b), Descr = "alle werksectoren zijn beperkt kwestbaar. Aanname is dat werken toch nabij/in bestaande stad komt en dus wel restrictief zal zijn.";
		
			parameter<float32>   AfstandGeluidsnorm                     := ='VariantParameters/VariantK/AfstandGeluidsnorm[VariantParameters/VariantK/V/'+Variant_name+']';
		}
	}
	
	container RestrictiesVoorSectorenAlsGevolgVanVervuilendWerken
	: Descr = "Rond nieuw werken (nijverheid en logistiek) niet direct wonen of andere lage milieucat subsectorne toestaan. Dus buffer daaromheen."
	{
		parameter<Bool> ExtraRestrictieDoorWerkAllocatieNodig                := VariantParameters/SectorAllocRegio/Uq_Sectors/HasWerkenSector, Descr = "Extra restricties door werken allocatie zijn nodig wanneer er in voorgaande stappen werken is gealloceerd.";
		
		attribute<Bool> Gealloceerd_Nijverheid        (CompactedAdminDomain) := StateVoorAllocatie/SubSector_rel == Sector/xSubsector/v/Werken_Nijverheid;
		attribute<Bool> Gealloceerd_Logistiek         (CompactedAdminDomain) := StateVoorAllocatie/SubSector_rel == Sector/xSubsector/v/Werken_Logistiek;
		
		attribute<Bool> Gealloceerd_Nijverheid_buffer (CompactedAdminDomain) := = ExtraRestrictieDoorWerkAllocatieNodig
																				? 'Buffer_Nijverheid/proximity_res'
																				: 'const(FALSE, CompactedAdminDomain)';
		attribute<Bool> Gealloceerd_Logistiek_buffer  (CompactedAdminDomain) := = ExtraRestrictieDoorWerkAllocatieNodig
																				? 'Buffer_Logistiek/proximity_res'
																				: 'const(FALSE, CompactedAdminDomain)';
	
		container Buffer_Nijverheid := Templates/Buffer_gridcel_T(Gealloceerd_Nijverheid,  /ModelParameters/Wonen/MilieuCat/Buffer_rond_Nijverheid[float64]);
		container Buffer_Logistiek  := Templates/Buffer_gridcel_T(Gealloceerd_Logistiek, /ModelParameters/Wonen/MilieuCat/Buffer_rond_Logistiek[float64]);
		
		attribute<Bool> IsNietToegestaan              (CompactedAdminDomain) := Gealloceerd_Nijverheid_buffer || Gealloceerd_Logistiek_buffer;
	}
	
	container StateNaAllocatie0 := ='Iters/LastIter/StateNaAllocatie', IntegrityCheck = "Iters/HasEnoughIteraties"
																		, Descr = "Check op genoeg iteraties. Is het stop criterium wel bereikt? 
																					Oftewel, is er in de laatste iter niks meer gealloceerd, en de claim wel gehaald, of geen geschikte locaties meer over?" //TO DO: nu staat dit feitelijk uitgeschakeld doordat het op statisch staat.
	{
		parameter<float32> TotalOverFlow := sum(Iters/LastIter/OverflowNaLastIter/All);
	}
	
	container StateNaAllocatie := PhaseContainer(StateNaAllocatie0, 'Finished '+Sector_name+' in '+AllocRegio_name+' with total overlow of: '+string(StateNaAllocatie0/TotalOverFlow));
}

