Template Iter_Landbouw_T
{
	//
	parameter<Iter> id;
	container StateVoorAllocatie;
	container Context0;
	unit<uint8> Iter; //IterK
	container Impl0;
	parameter<bool> IsEnkelIter;
	//
	
	parameter<string> name := Iter/name[id];
	
	container Context := Context0
	{
		container ThisIter := ..;
		parameter<string> ThisIterName := Iter/name[id];
		parameter<string> PrevIterName := Iter/prevname[id];
	}
	
	unit<uint8>  SubSector  := Context/ThisSectorAllocRegio/SubSector;
	unit<uint32> AllocRegio := Context/ThisSectorAllocRegio/AllocRegio;
	unit<uint8>  OP         := CaseClassifications/Vastgoed/OP;
	
	// Er zijn drie soorten IterSubsector templates, omdat voor wonen er een module over OP's nodig is, voor wind een deel over stempels, en voor de overige sectoren is het wel generiek.
	container Subsectoren :=
		for_each_ne(
			 SubSector/name
			, ''
		);
	
	container CaseData
	{
		container OrgLanduse:= /BaseData/StartState/Grondgebruik/per_AdminDomain/gg_Landbouw;

		container Suitabilities :=
			for_each_nedv(
				 SubSector/Name
				,'geschiktheid/ModelTypes/' + SubSector/Name + '/totaal'
				,domain_grid
				,EUR_M2
			);

		attribute<Bool>   IsAdditiveClaim(SubSector):= ='union_data(SubSector, '+asItemList('ClaimSet/'+SubSector/Name+'/IsAdditive')+')';
		attribute<String> RegioRefs      (SubSector):= ='union_data(SubSector, '+asItemList('ClaimSet/'+SubSector/Name+'/RegioUnit/RegioRef')+')';

		unit<UInt8> UniekeRegioRefs:= unique(RegioRefs)
		{
			attribute<String> Values;
		}

		container RegioGrids :=
			for_each_nedvn(
				 UniekeRegioRefs/Values
				,'bronnen/RegioGrids/'+UniekeRegioRefs/Values
				,domain_grid
				,Geography/RegioIndelingen
				,UniekeRegioRefs/Values
			);

		unit<uint16> AtomaireRegios:= overlay(UniekeRegioRefs/Values, domain_grid, RegioGrids)
		{
			attribute<AtomaireRegios> UnionData(domain_grid): Descr = "AtomaireRegioMap";
			attribute<AtomaireRegios> ID:= ID(AtomaireRegios);
		}

		container Land: Descr = "These attributes are used to describe the freeLand for allocation"
		{
			attribute<bool> FreeLand (domain_grid):= not(IsDefined(Opgelegd));

			unit<UInt32> FreeLandCells := subset(FreeLand)
			,	DialogType = "Map"
			,	DialogData = "BasisGrid"
			{
				attribute<domain_grid>   nr_OrgEntity;
				attribute<FreeLandCells> permutation:            = rnd_permutation(0, FreeLandCells);
				attribute<domain_grid>   nr_OrgEntity2:          = lookup(permutation, nr_OrgEntity);
				attribute<FreeLandCells> BasisGrid (domain_grid):= invert(nr_OrgEntity2);
			}
		}

		container TotalOpgelegd :=
			for_each_nednv(
				 SubSector/Name
				,'sum(
					  uint32(Opgelegd == value('+String(SubSector/nr_OrgEntity)+', ModelType))
					, bronnen/RegioGrids/'+RegioRefs +
				 ')'
				, Geography/RegioIndelingen
				, RegioRefs
				, UInt32
			), Descr = "Dj: Min Total Claims";

		container MinClaims_VoorOpleggen :=
			for_each_nednv(
				 AllocType/Name
				, 'UInt32(
					max_elem(
						 ClaimSet/'+AllocType/Name+'/claim_min / bronnen/nrHaPerCell'
						+(IsAdditiveClaim
							? '   +  sum(orgLandUse/ModelTypeData/ggRatio/'+AllocType/Name+', bronnen/RegioGrids/'+RegioRefs +')'
							: ''
						 )
						+', value(0.0, Ratio)
					)
				)'
				,Geography/RegioIndelingen
				,RegioRefs
				,UInt32
			), Descr = "Dj: Min Total Claims";

		container TotalMinClaims :=
			for_each_nednv(
				AllocType/Name
				,'TotalOpgelegd/'+AllocType/Name +' > MinClaims_VoorOpleggen/'+AllocType/Name+'
					? UInt32(TotalOpgelegd/'+AllocType/Name +' > MaxClaims_VoorOpleggen/'+AllocType/Name+')
					: MinClaims_VoorOpleggen/'+AllocType/Name+' - TotalOpgelegd/'+AllocType/Name
				,Geography/RegioIndelingen
				,RegioRefs
				,UInt32
			), Descr = "Dj: Min Total Claims";

		container MaxClaims_VoorOpleggen :=
			for_each_nednv(AllocType/Name
				,'UInt32(
					max_elem(
						MakeDefined(
							 ClaimSet/'+AllocType/Name+'/claim_max / bronnen/nrHaPerCell'
							 + ( IsAdditiveClaim
								? ' +  sum(orgLandUse/ModelTypeData/ggRatio/'+AllocType/Name+', bronnen/RegioGrids/'+RegioRefs +')'
								: ''
							 )
							 + ', value(pcount(Geography/RegioGrids/'+RegioRefs+'), Ratio)
						)
						, value(0.0, Ratio)
					)
					+ float32(0.5)
				 )'
				,Geography/RegioIndelingen
				,RegioRefs
				,UInt32
			), Descr = "Dj: Max Total Claims";

		container TotalMaxClaims :=
			for_each_nednv(
				 AllocType/Name
				,'TotalOpgelegd/'+AllocType/Name +' > MaxClaims_VoorOpleggen/'+AllocType/Name+'
					? 0
					: MaxClaims_VoorOpleggen/'+AllocType/Name+' - TotalOpgelegd/'+AllocType/Name
				, Geography/RegioIndelingen
				, RegioRefs
				, UInt32
			), Descr = "Dj: Max Total Claims";

		attribute<AtomaireRegios> CompacteAtomaireRegios(Land/FreeLandCells):= AtomaireRegios/UnionData[Land/FreeLandCells/nr_OrgEntity2];
		
		// Dit is de threshold, rescaled from EUR per Yr / m2 to EUR/Ha
		parameter<Eur_Ha_Int32> Threshold:= Int32(value(-999, EUR_M2) * value(10000, Meter2 / ggHa) * float32(12.46220836)); 

		container CompacteSuitabilities :=
			for_each_nedv(
				AllocType/Name
				,'MakeDefined(int32( lookup(Land/FreeLandCells/nr_OrgEntity2, Suitabilities/'+AllocType/Name+') * value(10000, Meter2 / ggHa)), Threshold - 1[Eur_Ha_Int32])'
				,Land/FreeLandCells
				,Eur_Ha_int32
			);
	}
	
	
	container d_alloc :=
		discrete_alloc(
			  AllocType/Name
			, CaseData/Land/FreeLandCells
			, CaseData/CompacteSuitabilities
			, rlookup(CaseData/RegioRefs, CaseData/UniekeRegioRefs/Values)
			, CaseData/UniekeRegioRefs/Values
			, CaseData/AtomaireRegios
			, CaseData/CompacteAtomaireRegios
			, CaseData/TotalMinClaims
			, CaseData/TotalMaxClaims
			, CaseData/Threshold
			, ClaimSummary/FeasibleSolution
		)
	{
		attribute<AllocType> landuse      (CaseData/Land/FreeLandCells);
		attribute<AllocType> landuse_grid (domain_grid) := landuse[CaseData/Land/FreeLandCells/BasisGrid], IntegrityCheck = "statusFlag";
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	container StateNaAllocatie0 := 
		for_each_ne(
			Sector/XSubsector/name
			, 'StatePrep_T('+string(id(Sector/XSubsector))+'[Sector/XSubsector], Context/ThisIter)'
		)
	{
		container PandFootprint :=
			for_each_nedv(
				Jobs6/name
				, sector_name == 'Werken' ? replace(impl/Update_Pandfootprint_expr,'@Y@', Context/ThisZichtjaar/name, '@SS@', Jobs6/name): replace(impl/Verdring_expr, '@S@', 'PandFootprint', '@SS@', Jobs6/name)
				, CompactedAdminDomain
				, m2PandFootprint
			);
	}
	
	container StateNaAllocatie1 :=
		for_each_neidv(
			Sector/XSubsector/name
			, 'StateNaAllocatie0/'+Sector/XSubsector/name+'/Result'
			, 'IsDefined(StateNaAllocatie0/'+Sector/XSubsector/name+'/Result)'
			, CompactedAdminDomain
			, float32
		)
	{
		attribute<Sector/XSubsector> Subsector_rel (CompactedAdminDomain) := MakeDefined(StateVoorAllocatie/Subsector_rel, Allocatie/per_SectorXSubSector);
		attribute<OP>                OP_rel        (CompactedAdminDomain) := MakeDefined(StateVoorAllocatie/OP_rel       , Allocatie/per_OP);
		
		container PandFootprint :=
			for_each_nedv(
				Jobs6/name
				, 'StateNaAllocatie0/PandFootprint/'+Jobs6/name
				, CompactedAdminDomain
				, m2PandFootprint
			);
		
		container Wind
		{
			attribute<Yr> jaartal_ingebruikname (CompactedAdminDomain) := Allocatie/per_SectorXSubSector == Classifications/Actor/Sector/XSubsector/V/Wind_Totaal ? uint16(right(Context/ThisZichtjaar/name,4))[Yr] : StateVoorAllocatie/Wind/jaartal_ingebruikname;
		}
	}

	// MET FENCECONTAINER
	container StateNaAllocatie2_metFence :=
		for_each_nedvn(
			CaseClassifications/StandVar/Path
			, 'value(StateNaAllocatie1/'+CaseClassifications/StandVar/Path + ', scope(CaseClassifications/StandVar, '+CaseClassifications/StandVar/unit_name+'))'
			, CompactedAdminDomain
			, CaseClassifications/StandVar
			, CaseClassifications/StandVar/unit_name
		)
	{
		container Wonen
		{
			attribute<Woning> Aantal_Woningen_Totaal (CompactedAdminDomain) := = 'add('+AsItemList(Classifications/Vastgoed/WP2xVSSH/name)+')';
		}
	}
	
	container StateNaAllocatie_metFence := FenceContainer(StateNaAllocatie2_metFence, 'Results for '+Context/ThisSequenceName+', '+Context/ThisSectorAllocRegioName+', '+Context/ThisIterName+' are finished calculating');
	
	//ZONDER FENCECONTAINER
	//Onderstaande twee parameters, en de expressie in de for_each zijn nodig om een 'blok' te creeren die altijd in zijn geheel wordt uitgerekend. Dit om bij generates van het zichtjaar efficient geheugengebruik te forceren.
	parameter<bool> AnyUndefined := ='OR('+AsItemList('!IsDefined(StateNaAllocatie1/'+CaseClassifications/StandVar/Path+'[0[CompactedAdminDomain]])')+')';
	parameter<bool> AllDefined   := NOT(AnyUndefined) && FALSE;
	
	container StateNaAllocatie2_zFence :=
		for_each_nedvn(
			CaseClassifications/StandVar/Path
			, 'value(AllDefined['+CaseClassifications/StandVar/value_type+'] + StateNaAllocatie1/'+CaseClassifications/StandVar/Path + ', scope(CaseClassifications/StandVar, '+CaseClassifications/StandVar/unit_name+'))'
			, CompactedAdminDomain
			, CaseClassifications/StandVar
			, CaseClassifications/StandVar/unit_name
		)
	{
		container Wonen
		{
			attribute<Woning> Aantal_Woningen_Totaal (CompactedAdminDomain) := = 'add('+AsItemList(Classifications/Vastgoed/WP2xVSSH/name)+')';
		}
	}
	
	container StateNaAllocatie_zFence := StateNaAllocatie2_zFence;
	container StateNaAllocatie := =ModelParameters/Use_Fence_operator ? 'StateNaAllocatie_metFence' : 'StateNaAllocatie_zFence';
}