Template Iter_Landbouw_T
{
	//
	parameter<Iter> id;
	container StateVoorAllocatie;
	container Context0;
	unit<uint8> Iter; //IterK
	container Impl0;
	parameter<bool> IsEnkelIter;
	//
	
	parameter<string> name := Iter/name[id];
	
	container Context := Context0
	{
		container ThisIter := ..;
		parameter<string> ThisIterName := Iter/name[id];
		parameter<string> PrevIterName := Iter/prevname[id];
	}
	
	unit<uint8>  SubSector  := Context/ThisSectorAllocRegio/SubSector
	{
		attribute<Partitioning> Partitioning_rel :=  const(0[Partitioning],.);
	}
	unit<uint32> AllocRegio := Context/ThisSectorAllocRegio/AllocRegio
	{
		attribute<.> id := id(.);
	}
	
	//Suitability per landuse type
	container Suitabilities :=
		for_each_nedv(
			 SubSector/Name
			, 'value(VariantData/Suitability/Landbouw_Indexation_DD/per_ModelType/' + SubSector/Name + '/totaal * 100f, int32)'
			, AllocDomain
			, int32
		);
		
	container CompactedSuitabilities :=
		for_each_nedv(
			SubSector/Name
			, 'collect_by_cond(CompactedAllocDomain, AllocDomain/IsCompactedDomain, Suitabilities/'+SubSector/Name+')'
			, CompactedAllocDomain
			, int32
		);
	
	//Atomic regions refer to the smallest regions present in the analysis. For example when you use COROP regions and some smaller region set that doesn't align with an aggregation of the latter. 
	//However, in this case we only use one region set: COROP. And this attribute gives a grid representation of the aggregation regions
	attribute<AllocRegio> AtomicRegionMap (CompactedAllocDomain) := AllocRegio/per_CompactedAllocDomain;
	
	unit<uint32> AtomicRegions := AllocRegio
	{
		attribute<.> regio := id(.);
	}	
	
	container RegionSets :=
		for_each_nedv(
			SubSector/name
			, 'AllocRegio/per_AllocDomain'
			, AllocDomain
			, AllocRegio
		);

	container Claims
	{
		container Current := 
			for_each_nedv(
				  SubSector/name
				, 'sum(StateVoorAllocatie/'+SubSector/Sector_name_ThisName+', AllocRegio/per_CompactedAdminDomain)[uint32]'
				, AllocRegio
				, uint32
			);
		container Maxclaims := 
			for_each_nedv(
				  SubSector/name
				, replace('uint32(VariantData/Claims/@Z@/SectorAllocRegios/@AS@/'+SubSector/name+')'
						,'@Z@' , Context/ThisZichtjaar/name
						,'@AS@', Context/ThisSectorAllocRegio/name)
				, AllocRegio
				, uint32
			);
		// container Maxclaims := 
			// for_each_nedv(
				  // SubSector/name
				// , 'Claim/'+SubSector/name+' - Current/'+SubSector/name
				// , AllocRegio
				// , uint32
			// )
		// {
			// attribute<uint32> Totaal (AllocRegio) := = 'add('+AsItemList(SubSector/name)+')';
		// }
		
		container minclaims := 
			for_each_nedv(
				  SubSector/name
				, 'const(0, AllocRegio)'
				, AllocRegio
				, uint32
			)
		{
			attribute<uint32> Totaal (AllocRegio) := = 'add('+AsItemList(SubSector/name)+')';
		}
		
	}

	//This partitioning refers to the partioning from the atomic regions, the 'id' defined here is the id from AtomicRegionMap/id.
	unit<uint8> Partitioning : nrofrows = 1
	{ 
	   attribute<string> name   : ['regio'];
	}
	
	//This threshold is not used.
	parameter<int32> threshold := int32(0);
	
	//This empty container is not used.
	container FeasibleSolution;

	container Disc_alloc := 
		discrete_alloc(
			  SubSector/name									// 1 string 	attribute
			, CompactedAllocDomain								// 2 uint32		unit
			, CompactedSuitabilities 							// 3 int32		container
			, Subsector/Partitioning_rel					// 4 uint8		attribute
			, Partitioning/name									// 5 string		attribute
			, AtomicRegions										// 6 uint16		unit
			, AtomicRegionMap									// 7 uint16		attribute
			, Claims/minclaims									// 8 uint32		container
			, Claims/maxclaims									// 9 uint32		container
			, threshold											// 10 int32		parameter
			, FeasibleSolution									// 11 (empty)	container
		);
		
	// container Disc_alloc := 
		// discrete_alloc(
			  // SubSector/name									// 1 string 	attribute
			// , CompactedAllocDomain								// 2 uint32		unit
			// , CompactedSuitabilities 							// 3 int32		container
			// , id(SubSector)										// 4 uint8		attribute
			// , SubSector/label									// 5 string		attribute
			// , AtomicRegions										// 6 uint16		unit
			// , AtomicRegionMap									// 7 uint16		attribute
			// , Claims/minclaims									// 8 uint32		container
			// , Claims/maxclaims									// 9 uint32		container
			// , threshold											// 10 int32		parameter
			// , FeasibleSolution									// 11 (empty)	container
		// );
		

	// issue: result-sub-items are now not visible in the GUI. each reault must be queried explicitly.
	// This relation shows the discrete allocation result with the correct landuse classes as value type.
	// attribute<SubSector> LandUse_rel(Input/Compacted/ADomain) := Disc_alloc/landuse;
	
	
	// container StateNaAllocatie0 := 
		// for_each_ne(
			// Sector/XSubsector/name
			// , 'StatePrep_T('+string(id(Sector/XSubsector))+'[Sector/XSubsector], Context/ThisIter)'
		// )
	// {
		// container PandFootprint :=
			// for_each_nedv(
				// Jobs6/name
				// , sector_name == 'Werken' ? replace(impl/Update_Pandfootprint_expr,'@Y@', Context/ThisZichtjaar/name, '@SS@', Jobs6/name): replace(impl/Verdring_expr, '@S@', 'PandFootprint', '@SS@', Jobs6/name)
				// , CompactedAdminDomain
				// , m2PandFootprint
			// );
	// }
	
	// container StateNaAllocatie1 :=
		// for_each_neidv(
			// Sector/XSubsector/name
			// , 'StateNaAllocatie0/'+Sector/XSubsector/name+'/Result'
			// , 'IsDefined(StateNaAllocatie0/'+Sector/XSubsector/name+'/Result)'
			// , CompactedAdminDomain
			// , float32
		// )
	// {
		// attribute<Sector/XSubsector> Subsector_rel (CompactedAdminDomain) := MakeDefined(StateVoorAllocatie/Subsector_rel, Allocatie/per_SectorXSubSector);
		// attribute<OP>                OP_rel        (CompactedAdminDomain) := MakeDefined(StateVoorAllocatie/OP_rel       , Allocatie/per_OP);
		
		// container PandFootprint :=
			// for_each_nedv(
				// Jobs6/name
				// , 'StateNaAllocatie0/PandFootprint/'+Jobs6/name
				// , CompactedAdminDomain
				// , m2PandFootprint
			// );
		
		// container Wind
		// {
			// attribute<Yr> jaartal_ingebruikname (CompactedAdminDomain) := Allocatie/per_SectorXSubSector == Classifications/Actor/Sector/XSubsector/V/Wind_Totaal ? uint16(right(Context/ThisZichtjaar/name,4))[Yr] : StateVoorAllocatie/Wind/jaartal_ingebruikname;
		// }
	// }

	// MET FENCECONTAINER
	// container StateNaAllocatie2_metFence :=
		// for_each_nedvn(
			// CaseClassifications/StandVar/Path
			// , 'value(StateNaAllocatie1/'+CaseClassifications/StandVar/Path + ', scope(CaseClassifications/StandVar, '+CaseClassifications/StandVar/unit_name+'))'
			// , CompactedAdminDomain
			// , CaseClassifications/StandVar
			// , CaseClassifications/StandVar/unit_name
		// )
	// {
		// container Wonen
		// {
			// attribute<Woning> Aantal_Woningen_Totaal (CompactedAdminDomain) := = 'add('+AsItemList(Classifications/Vastgoed/WP2xVSSH/name)+')';
		// }
	// }
	
	// container StateNaAllocatie_metFence := FenceContainer(StateNaAllocatie2_metFence, 'Results for '+Context/ThisSequenceName+', '+Context/ThisSectorAllocRegioName+', '+Context/ThisIterName+' are finished calculating');
	
	//ZONDER FENCECONTAINER
	//Onderstaande twee parameters, en de expressie in de for_each zijn nodig om een 'blok' te creeren die altijd in zijn geheel wordt uitgerekend. Dit om bij generates van het zichtjaar efficient geheugengebruik te forceren.
	// parameter<bool> AnyUndefined := ='OR('+AsItemList('!IsDefined(StateNaAllocatie1/'+CaseClassifications/StandVar/Path+'[0[CompactedAdminDomain]])')+')';
	// parameter<bool> AllDefined   := NOT(AnyUndefined) && FALSE;
	
	// container StateNaAllocatie2_zFence :=
		// for_each_nedvn(
			// CaseClassifications/StandVar/Path
			// , 'value(AllDefined['+CaseClassifications/StandVar/value_type+'] + StateNaAllocatie1/'+CaseClassifications/StandVar/Path + ', scope(CaseClassifications/StandVar, '+CaseClassifications/StandVar/unit_name+'))'
			// , CompactedAdminDomain
			// , CaseClassifications/StandVar
			// , CaseClassifications/StandVar/unit_name
		// )
	// {
		// container Wonen
		// {
			// attribute<Woning> Aantal_Woningen_Totaal (CompactedAdminDomain) := = 'add('+AsItemList(Classifications/Vastgoed/WP2xVSSH/name)+')';
		// }
	// }
	
	// container StateNaAllocatie_zFence := StateNaAllocatie2_zFence;
	// container StateNaAllocatie := =ModelParameters/Use_Fence_operator ? 'StateNaAllocatie_metFence' : 'StateNaAllocatie_zFence';
}