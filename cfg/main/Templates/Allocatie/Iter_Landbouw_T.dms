Template Iter_Landbouw_T
: Descr = "Template for one iteration of the Landbouw allocation"
{
	parameter<Iter> id;
	container StateVoorAllocatie0;
	container Context0;
	unit<UInt8> Iter; //IterK
	container Impl0;
	parameter<Bool> IsEnkelIter;
	//
	
	parameter<String> name := Iter/name[id];
	
	container Context := Context0
	{
		container ThisIter := ..;
		parameter<String> ThisItername := Iter/name[id];
		parameter<String> PrevItername := Iter/PrevName[id];
	}	
	
	container StateVoorAllocatie := =ModelParameters/OntkoppelStedelijkeKlasses 
										? '/Allocatie/Zichtjaren/'+Context/ThisZichtjaar_name+'/Impl/ReadStand_Compacted'
										: 'StateVoorAllocatie0'
	, Descr = "Om ontkoppelde stedelijke functies te gebruiken wanneer dit zo ingesteld wordt.";
	
	container Subsectoren :=
		for_each_ne(
			 Allocatie_Prep/Subsector/name
			, 'IterSubsector_T_Landbouw('+string(id(Allocatie_Prep/Subsector))+'[Allocatie_Prep/Subsector],Allocatie_Prep/Subsector,StateVoorAllocatie,Context)'
	), Descr = "aanroep van IterSubsector_T_Landbouw voor elke landbouw subsector";
	
	container Allocatie_Prep : Descr = "Voorbereidingen voor de allocatie, zoals het inlezen van suitability maps, claims, etc."
	{
		unit<UInt8>  Subsector  := = 'LandbouwK_Alloc';
		unit<UInt32> AllocRegio := Context/ThisSectorAllocRegio/AllocRegio
		{
			attribute<.> id := id(.), Descr = "was relevant voor oude discr_alloc, nu niet meer";
		}
		
		container ExogeenOpleggen
		: Descr = "Hierin staat per AdminDomain of er exogeen areaal wordt opgelegd, en zo ja, hoeveel."
		{
			attribute<LU_ModelType> Totaal          (AdminDomain) := VariantData/ExogeenOpleggen/Totaal;
			attribute<Bool>         Beschikbaar     (AdminDomain) := IsNull(Totaal);
		}

		container Suitabilities :=
			for_each_nedv(
				Subsector/name
				, 'Subsectoren/'+Subsector/name+'/CompactedAdminDomain/Beschikbaar 
					&& collect_by_cond(CompactedAdminDomain, AdminDomain/IsCompactedDomain, ExogeenOpleggen/Beschikbaar) 
						? value(collect_by_cond(CompactedAdminDomain, AdminDomain/IsCompactedDomain, VariantData/Suitability/'+Context/ThisZichtjaar_name+'/Landbouw/per_ModelType/'+Subsector/name+'/Suitability) * 100f, int32) 
						: null_i'
				, CompactedAdminDomain
				, int32
			), Descr = "Suitability maps voor alle subsectoren, met 100 vermenigvuldigd. Dit is nodig omdat discr_alloc alleen met integers kan werken. Omdat de suitability tussen 0 en 1 ligt, en we precisie willen behouden, vermenigvuldigen we met 100. Dus een suitability van 0.75 wordt 75 in de int map."
		{
			attribute<Subsector> ArgMax (CompactedAdminDomain) := ='ArgMax_ifdefined('+asItemList(Subsector/name)+')[Subsector]', Descr = "Deze attribute geeft per cel aan welke subsector de hoogste suitability heeft. Enkel voor debug purposes.";
		}

		attribute<AllocRegio> AtomicRegionMap (CompactedAdminDomain) := AllocRegio/Per_CompactedAdminDomain;
		
		unit<UInt32> AtomicRegions := AllocRegio
		{
			attribute<.> regio := id(.);
		}	
		
		container Claims
		{
			parameter<Ha> AreaalStudyGebied := area(rdc_meter/geometry[0], meter2)[ha];
			
			container MaxClaims := 
				for_each_nedv(
					  Subsector/name
					, replace('uint32(VariantData/Claims/@Z@/SectorAllocRegios/@AS@/MaxClaims/'+Subsector/name+AllocRegio_StudyArea_orgrel+' / AdminDomain/NrHaPerCell)'
							,'@Z@' , Context/ThisZichtjaar/name
							,'@AS@', Context/ThisSectorAllocRegio/name)
					, AllocRegio
					, uint32
				), Descr = "MaxClaims per subsector per allocatieregio. Dit is het maximum areaal dat geclaimd kan worden in de allocatieregio, verdeeld over de cells in de allocatieregio. Dit is dus een absolute bovengrens, die niet overschreden kan worden. Het kan dus zijn dat er minder wordt geclaimd, maar nooit meer. Dit is een harde grens.";
			
			container MinClaims := 
				for_each_nedv(
					  Subsector/name
					, replace('uint32(VariantData/Claims/@Z@/SectorAllocRegios/@AS@/MinClaims/'+Subsector/name+AllocRegio_StudyArea_orgrel+' / AdminDomain/NrHaPerCell)'
							,'@Z@' , Context/ThisZichtjaar/name
							,'@AS@', Context/ThisSectorAllocRegio/name)
					, AllocRegio
					, uint32
				), Descr = "MinClaims per subsector per allocatieregio. Dit is het minimum areaal dat geclaimd moet worden in de allocatieregio, verdeeld over de cells in de allocatieregio. Dit is dus een absolute ondergrens, die niet onderschreden kan worden. Het kan dus zijn dat er meer wordt geclaimd, maar nooit minder. Dit is een harde grens.";
		}
		
		parameter<Int32> threshold := -999999i, Descr = "Threshold voor suitability maps in discr_alloc. Omdat de suitability maps met 100 vermenigvuldigd zijn, is deze threshold ook met 100 vermenigvuldigd. Dus een threshold van 50 betekent dat alleen cells met een suitability van 0.50 of hoger in aanmerking komen voor allocatie. Een threshold van -999999 betekent dat alle cells in aanmerking komen.";
	}
	
	container Allocatie := 
		discrete_alloc_sp(
			  Allocatie_Prep/Subsector/name										// 1 string 	attribute	Typenames
			, CompactedAdminDomain												// 2 uint32		unit
			, Allocatie_Prep/Suitabilities 										// 3 int32		container	SuitabilityMaps
			, Allocatie_Prep/AtomicRegions										// 6 UInt16		unit		Regions
			, Allocatie_Prep/AtomicRegionMap									// 7 UInt16		attribute	RegionMap
			, Allocatie_Prep/Claims/MinClaims									// 8 uint32		container	MinClaims
			, Allocatie_Prep/Claims/MaxClaims									// 9 uint32		container	MaxClaims
			, Allocatie_Prep/threshold											// 10 int32		parameter	Threshold
		), Descr = "Discret allocation algorithm, adapted for Landbouw. Allocates areaal to subsectoren based on suitability maps and claims. The output is an attribute per cell with the allocated subsector."
	{
		parameter<Bool> IsConversatieveBoer := /ModelParameters/Landbouw/Boervariant == BoervariantK/V/ConservatieveBoer;
	
		attribute<Subsector>                        Alloc_Result         (CompactedAdminDomain) := =IsConversatieveBoer ? 'const(null_b, CompactedAdminDomain, Subsector)' : 'Allocatie_Prep/Subsector/LandbouwK_rel[landuse]', Descr = "Resultaat van de allocatie, per cell de gealloceerde subsector. Bij de conversatieve boer wordt er niets gealloceerd, dus dan is het resultaat overal null. Dus dan blijft huidig landgebruiks staan.";
		attribute<Sector/xSubsector>                per_SectorxSubsector (CompactedAdminDomain) := rlookup(Alloc_Result, Sector/xSubsector/LandbouwK_rel); // TO DO weer insschakelen, IntegrityCheck = "statusFlag";
	}

	attribute<Bool> IsNuGealloceerd (CompactedAdminDomain) := IsDefined(Allocatie/Alloc_Result);
	
	container Impl := Impl0
	{
		parameter<Bool> StopCriterium       := StaticStopCriterium;
		parameter<Bool> StaticStopCriterium := IsEnkelIter ? TRUE : id == (ModelParameters/Default_NrOfIters - 1b)[Iter];
	}
	
	container StateNaAllocatie0 := 
		for_each_ne(
			Sector/xSubsector/name
			, 'StatePrep_T('+string(id(Sector/xSubsector))+'[Sector/xSubsector], Context/ThisIter)'
		)
	{
		container PandFootprint :=
			for_each_nedv(
				Jobs6/name
				, lowercase(Sector_name) == lowercase('Werken') ? replace(Impl/Update_PandFootprint_Expr,'@Y@', Context/ThisZichtjaar/name, '@SS@', Jobs6/name): replace(Impl/Verdring_Expr, '@S@', 'PandFootprint', '@SS@', Jobs6/name)
				, CompactedAdminDomain
				, m2PandFootprint
			);
	}
	
	container StateNaAllocatie1 :=
		for_each_neidv(
			Sector/xSubsector/name
			, 'StateNaAllocatie0/'+Sector/xSubsector/name+'/Result'
			, 'IsDefined(StateNaAllocatie0/'+Sector/xSubsector/name+'/Result)'
			, CompactedAdminDomain
			, float32
		)
	{
		attribute<Sector/XSubsector> Subsector_rel0 (CompactedAdminDomain) := switch(
																				case(Sector/XSubsector/IsLandbouw[StateVoorAllocatie/Subsector_rel], null_b)
																				, StateVoorAllocatie/Subsector_rel
																				); 
		attribute<Sector/XSubsector> Subsector_rel (CompactedAdminDomain) := =ModelParameters/OntkoppelStedelijkeKlasses ? 'MakeDefined(Subsector_rel0, Allocatie/per_SectorXSubSector)' : 'MakeDefined(StateVoorAllocatie/Subsector_rel, Allocatie/per_SectorXSubSector)';
		attribute<OP>                OP_rel        (CompactedAdminDomain) := StateVoorAllocatie/OP_rel;
		
		container PandFootprint :=
			for_each_nedv(
				Jobs6/name
				, 'StateNaAllocatie0/PandFootprint/'+Jobs6/name
				, CompactedAdminDomain
				, m2PandFootprint
			);
		
		container Wind
		{
			attribute<Yr>    Jaartal_ingebruikname (CompactedAdminDomain) := =VariantParameters/SectorAllocRegio/Uq_Sectors/HasWindSector ? 'Allocatie/per_SectorxSubsector == Sector/xSubsector/V/Wind_Totaal ? UInt16(right(Context/ThisZichtjaar/name,4))[Yr] : StateVoorAllocatie/Wind/jaartal_ingebruikname' : 'StateVoorAllocatie/Wind/jaartal_ingebruikname';
			attribute<Meter> Ashoogte              (CompactedAdminDomain) := =VariantParameters/SectorAllocRegio/Uq_Sectors/HasWindSector ? 'Allocatie/per_SectorxSubsector == Sector/xSubsector/V/Wind_Totaal ? /CaseClassifications/WindTurbineType/Ashoogte : StateVoorAllocatie/Wind/Ashoogte' : 'StateVoorAllocatie/Wind/Ashoogte';
			attribute<Meter> Rotordiameter         (CompactedAdminDomain) := =VariantParameters/SectorAllocRegio/Uq_Sectors/HasWindSector ? 'Allocatie/per_SectorxSubsector == Sector/xSubsector/V/Wind_Totaal ? /CaseClassifications/WindTurbineType/Rotordiameter : StateVoorAllocatie/Wind/Rotordiameter' : 'StateVoorAllocatie/Wind/Rotordiameter';
			attribute<Meter> MaxWerpAfstandNom     (CompactedAdminDomain) := =VariantParameters/SectorAllocRegio/Uq_Sectors/HasWindSector ? 'Allocatie/per_SectorxSubsector == Sector/xSubsector/V/Wind_Totaal ? /CaseClassifications/WindTurbineType/MaxWerpAfstandNom : StateVoorAllocatie/Wind/MaxWerpAfstandNom' : 'StateVoorAllocatie/Wind/MaxWerpAfstandNom';
		}
	}

	container StateNaAllocatie2 :=
		for_each_nedvn(
			CaseClassifications/StandVar/Path
			, 'value(StateNaAllocatie1/'+CaseClassifications/StandVar/Path + ', scope(CaseClassifications/StandVar, '+CaseClassifications/StandVar/unit_name+'))'
			, CompactedAdminDomain
			, CaseClassifications/StandVar
			, CaseClassifications/StandVar/unit_name
		)
	{
		container Wonen
		{
			attribute<Woning> Aantal_Woningen_Totaal (CompactedAdminDomain) := = 'add('+asItemList(Classifications/Vastgoed/WP2xVSSH/name)+')';
		}
	}
	
	container StateNaAllocatie_P := PhaseContainer(StateNaAllocatie2, 'Results for '+Context/ThisSequencename+', '+Context/ThisSectorAllocRegioname+', '+Context/ThisItername+' are finished calculating');
	container StateNaAllocatie   := =ModelParameters/UsePhaseContainer ? 'StateNaAllocatie_P' : 'StateNaAllocatie2';
	
	container Stand_PerAllocRegio := 
		for_each_nedvn(
			CaseClassifications/StandVar/Path
			, 'sum(StateNaAllocatie/'+CaseClassifications/StandVar/Path+', AllocRegio/Per_CompactedAdminDomain)'
			, AllocRegio
			, CaseClassifications/StandVar
			, CaseClassifications/StandVar/unit_name
		), Descr = "De stand variabelen na allocatie worden opgeteld per allocatieregio."
	{
		container wonen
		{
			attribute<Woning> Aantal_Woningen_Totaal (AllocRegio) := = 'add('+asItemList(Classifications/Vastgoed/WP2xVSSH/name)+')';
		}
	}
	
}