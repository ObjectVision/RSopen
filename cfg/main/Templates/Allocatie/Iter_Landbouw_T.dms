Template Iter_Landbouw_T
{
	//
	parameter<Iter> id;
	container StateVoorAllocatie;
	container Context0;
	unit<uint8> Iter; //IterK
	container Impl0;
	parameter<bool> IsEnkelIter;
	//
	
	parameter<string> name := Iter/name[id];
	
	container Context := Context0
	{
		container ThisIter := ..;
		parameter<string> ThisIterName := Iter/name[id];
		parameter<string> PrevIterName := Iter/prevname[id];
	}	
	
	container Subsectoren :=
		for_each_ne(
			 Allocatie_Prep/SubSector/name
			, 'IterSubsector_T_Landbouw('+string(id(Allocatie_Prep/SubSector))+'[Allocatie_Prep/SubSector],Allocatie_Prep/SubSector,StateVoorAllocatie,Context)'
	);
	
	container Allocatie_Prep
	{
		unit<uint8> SubSector  := LandbouwK_Alloc
		{
			attribute<Partitioning> Partitioning_rel :=  const(0[Partitioning],.);
		}
		unit<uint32> AllocRegio := Context/ThisSectorAllocRegio/AllocRegio
		{
			attribute<.> id := id(.);
		}
		
		container ExogeenOpleggen
		{
			attribute<LU_ModelType> Totaal          (AdminDomain) := VariantData/ExogeenOpleggen/Totaal;
			attribute<bool>         Beschikbaar     (AdminDomain) := IsNull(Totaal);
		}
		container Suitabilities :=
			for_each_nedv(
				SubSector/Name
				, 'Subsectoren/'+SubSector/Name+'/CompactedAllocDomain/Beschikbaar && collect_by_cond(CompactedAllocDomain, AllocDomain/IsCompactedDomain, modus(ExogeenOpleggen/Beschikbaar, AdminDomain/AllocDomain_rel)) ? value(collect_by_cond(CompactedAllocDomain, AllocDomain/IsCompactedDomain, VariantData/Suitability/'+Context/ThisZichtjaar_name+'/Landbouw/per_ModelType/'+SubSector/Name+'/totaal) * 100f, int32) : null_i'
				, CompactedAllocDomain
				, int32
			);

		attribute<AllocRegio> AtomicRegionMap (CompactedAllocDomain) := AllocRegio/per_CompactedAllocDomain;
		
		unit<uint32> AtomicRegions := AllocRegio
		{
			attribute<.> regio := id(.);
		}	
		
		
		container RegionSets :=
			for_each_nedv(
				SubSector/name
				, 'AllocRegio/per_CompactedAllocDomain'
				, CompactedAllocDomain
				, AllocRegio
			);

		container Claims
		{
			container Current := 
				for_each_nedv(
					  SubSector/name
					, 'sum(StateVoorAllocatie/'+SubSector/Sector_name_ThisName+', AllocRegio/per_CompactedAdminDomain)[uint32]'
					, AllocRegio
					, uint32
				);
			container Maxclaims_Defined := 
				for_each_nedv(
					  SubSector/name
					, replace('uint32(VariantData/Claims/@Z@/SectorAllocRegios/@AS@/'+SubSector/name+AllocRegio_StudyArea_orgrel+' * (1f + ModelParameters/Landbouw/Landbouw_Claim_Growth))'
							,'@Z@' , Context/ThisZichtjaar/name
							,'@AS@', Context/ThisSectorAllocRegio/name)
					, AllocRegio
					, uint32
				);
			container Maxclaims_Undefined := 
				for_each_nedv(
					  SubSector/name
					, 'const(null_u, AllocRegio)'
					, AllocRegio
					, uint32
				);
				
			container Minclaims_Defined0 := 
				for_each_nedv(
					  SubSector/name
					, replace('uint32(VariantData/Claims/@Z@/SectorAllocRegios/@AS@/'+SubSector/name+AllocRegio_StudyArea_orgrel+' * (1f - ModelParameters/Landbouw/Landbouw_Claim_Growth))'
							,'@Z@' , Context/ThisZichtjaar/name
							,'@AS@', Context/ThisSectorAllocRegio/name)
					, AllocRegio
					, uint32
				);
			container Minclaims_Defined := 
				for_each_nedv(
					  SubSector/name
					, SubSector/name == 'NonLandbouw' ? 'const(0, AllocRegio)' : 'Minclaims_Defined0/'+SubSector/name
					, AllocRegio
					, uint32
				);
				
			container minclaims_zero := 
				for_each_nedv(
					  SubSector/name
					, 'const(0, AllocRegio)'
					, AllocRegio
					, uint32
				);
			
			container minclaims_manual
			{
				attribute<uint32>   Rietteelt        (AllocRegio) := const(0, AllocRegio);
				attribute<uint32>   Akkerbouw        (AllocRegio) := const(0, AllocRegio);
				// attribute<uint32>   Groenteteelt     (AllocRegio) := Current/Groenteteelt;
				// attribute<uint32>   Fruitteelt       (AllocRegio) := Current/Fruitteelt;
				attribute<uint32>   Boomgaard        (AllocRegio) := Current/Boomgaard;
				// attribute<uint32>   Boomkwekerij     (AllocRegio) := Current/Boomkwekerij;
				attribute<uint32>   gg_vee_extensief (AllocRegio) := const(0, AllocRegio);
				attribute<uint32>   gg_vee           (AllocRegio) := const(0, AllocRegio);
				attribute<uint32>   gg_vee_intensief (AllocRegio) := const(0, AllocRegio);
				attribute<uint32>   moerasbomen      (AllocRegio) := const(0, AllocRegio);
				attribute<uint32>   cranberry      (AllocRegio) := const(0, AllocRegio);
				attribute<uint32>   rijst      (AllocRegio) := const(0, AllocRegio);
				attribute<uint32>   yacon      (AllocRegio) := const(0, AllocRegio);
				attribute<uint32>   NonLandbouw      (AllocRegio) := const(0, AllocRegio);
			}
			
			container maxclaims_manual
			{
				attribute<uint32>   Rietteelt        (AllocRegio) := const(null_u, AllocRegio);
				attribute<uint32>   Akkerbouw        (AllocRegio) := uint32(Current/Akkerbouw[float32]        * (1f + ModelParameters/Landbouw/Landbouw_Claim_Growth));
				// attribute<uint32>   Groenteteelt     (AllocRegio) := Current/Groenteteelt;
				// attribute<uint32>   Fruitteelt       (AllocRegio) := Current/Fruitteelt;
				attribute<uint32>   Boomgaard        (AllocRegio) := Current/Boomgaard;
				attribute<uint32>   Moerasbomen      (AllocRegio) := Current/Moerasbomen;
				attribute<uint32>   Yacon            (AllocRegio) := Current/Yacon;
				attribute<uint32>   Rijst            (AllocRegio) := Current/Rijst;
				attribute<uint32>   Cranberry        (AllocRegio) := Current/Cranberry;
				// attribute<uint32>   Boomkwekerij     (AllocRegio) := Current/Boomkwekerij;
				attribute<uint32>   gg_vee_extensief (AllocRegio) := uint32(Current/gg_vee_extensief[float32] * (1f + ModelParameters/Landbouw/Landbouw_Claim_Growth));
				attribute<uint32>   gg_vee           (AllocRegio) := uint32(Current/gg_vee[float32]           * (1f + ModelParameters/Landbouw/Landbouw_Claim_Growth));
				attribute<uint32>   gg_vee_intensief (AllocRegio) := uint32(Current/gg_vee_intensief[float32] * (1f + ModelParameters/Landbouw/Landbouw_Claim_Growth));
				attribute<uint32>   NonLandbouw      (AllocRegio) := Maxclaims_Defined/NonLandbouw;
			}
			
			container maxclaims := =ModelParameters/Landbouw/ClaimVariant == 'Manual' 
										? 'maxclaims_manual' 
										: ModelParameters/Landbouw/ClaimVariant == 'ConstGrowthMinMax'
											? 'Maxclaims_Defined' 
											: 'Maxclaims_Undefined';
											
			container minclaims := =ModelParameters/Landbouw/ClaimVariant == 'Manual' 
										? 'minclaims_manual' 
										: ModelParameters/Landbouw/ClaimVariant == 'ConstGrowthMinMax'
											? 'Minclaims_Defined' 
											: 'minclaims_zero';
		}

		unit<uint8> Partitioning : nrofrows = 1
		{ 
		   attribute<string> name   :['regio'];
		}
	
		parameter<int32> threshold := 0i; 	//This threshold is not used
		container FeasibleSolution; //This empty container is not used.
	}
	
	container Allocatie := 
		discrete_alloc(
			  Allocatie_Prep/SubSector/name									// 1 string 	attribute
			, CompactedAllocDomain								// 2 uint32		unit
			, Allocatie_Prep/Suitabilities 							// 3 int32		container
			, Allocatie_Prep/Subsector/Partitioning_rel					// 4 uint8		attribute
			, Allocatie_Prep/Partitioning/name									// 5 string		attribute
			, Allocatie_Prep/AtomicRegions										// 6 uint16		unit
			, Allocatie_Prep/AtomicRegionMap									// 7 uint16		attribute
			, Allocatie_Prep/Claims/minclaims									// 8 uint32		container
			, Allocatie_Prep/Claims/maxclaims									// 9 uint32		container
			, Allocatie_Prep/threshold											// 10 int32		parameter
			, Allocatie_Prep/FeasibleSolution									// 11 (empty)	container
		)
	{
		attribute<Allocatie_Prep/SubSector>         Alloc_Result0        (CompactedAdminDomain) := landuse[CompactedAdminDomain/CompactedAllocDomain_rel];
		attribute<SubSector>                        Alloc_Result         (CompactedAdminDomain) := rjoin(Alloc_Result0, id(Allocatie_Prep/SubSector), Allocatie_Prep/SubSector/LandbouwK_rel);
		attribute<Sector/XSubsector>                per_SectorXSubSector (CompactedAdminDomain) := rjoin(Alloc_Result, Sector/XSubsector/LandbouwK_rel, id(Sector/XSubsector));
	}

	attribute<bool> IsNuGealloceerd (CompactedAdminDomain) := IsDefined(Allocatie/Alloc_Result);
	
	container impl := impl0
	{
		parameter<bool> StopCriterium       := StaticStopCriterium;
		parameter<bool> StaticStopCriterium := IsEnkelIter ? TRUE : id == (ModelParameters/Default_NrOfIters - 1b)[Iter];
	}
	
	container StateNaAllocatie0 := 
		for_each_ne(
			Sector/XSubsector/name
			, 'StatePrep_T('+string(id(Sector/XSubsector))+'[Sector/XSubsector], Context/ThisIter)'
		)
	{
		container PandFootprint :=
			for_each_nedv(
				Jobs6/name
				, sector_name == 'Werken' ? replace(impl/Update_Pandfootprint_expr,'@Y@', Context/ThisZichtjaar/name, '@SS@', Jobs6/name): replace(impl/Verdring_expr, '@S@', 'PandFootprint', '@SS@', Jobs6/name)
				, CompactedAdminDomain
				, m2PandFootprint
			);
	}
	
	container StateNaAllocatie1 :=
		for_each_neidv(
			Sector/XSubsector/name
			, 'StateNaAllocatie0/'+Sector/XSubsector/name+'/Result'
			, 'IsDefined(StateNaAllocatie0/'+Sector/XSubsector/name+'/Result)'
			, CompactedAdminDomain
			, float32
		)
	{
		attribute<Sector/XSubsector> Subsector_rel (CompactedAdminDomain) := MakeDefined(StateVoorAllocatie/Subsector_rel, Allocatie/per_SectorXSubSector);
		attribute<OP>                OP_rel        (CompactedAdminDomain) := StateVoorAllocatie/OP_rel;
		
		container PandFootprint :=
			for_each_nedv(
				Jobs6/name
				, 'StateNaAllocatie0/PandFootprint/'+Jobs6/name
				, CompactedAdminDomain
				, m2PandFootprint
			);
		
		container Wind
		{
			attribute<Yr> jaartal_ingebruikname (CompactedAdminDomain) := Allocatie/per_SectorXSubSector == Classifications/Actor/Sector/XSubsector/V/Wind_Totaal ? uint16(right(Context/ThisZichtjaar/name,4))[Yr] : StateVoorAllocatie/Wind/jaartal_ingebruikname;
		}
	}

	// MET FENCECONTAINER
	container StateNaAllocatie2_metFence :=
		for_each_nedvn(
			CaseClassifications/StandVar/Path
			, 'value(StateNaAllocatie1/'+CaseClassifications/StandVar/Path + ', scope(CaseClassifications/StandVar, '+CaseClassifications/StandVar/unit_name+'))'
			, CompactedAdminDomain
			, CaseClassifications/StandVar
			, CaseClassifications/StandVar/unit_name
		)
	{
		container Wonen
		{
			attribute<Woning> Aantal_Woningen_Totaal (CompactedAdminDomain) := = 'add('+AsItemList(Classifications/Vastgoed/WP2xVSSH/name)+')';
		}
	}
	container StateNaAllocatie_metFence := FenceContainer(StateNaAllocatie2_metFence, 'Results for '+Context/ThisSequenceName+', '+Context/ThisSectorAllocRegioName+', '+Context/ThisIterName+' are finished calculating');
	
	//ZONDER FENCECONTAINER
	//Onderstaande twee parameters, en de expressie in de for_each zijn nodig om een 'blok' te creeren die altijd in zijn geheel wordt uitgerekend. Dit om bij generates van het zichtjaar efficient geheugengebruik te forceren.
	parameter<bool> AnyUndefined := ='OR('+AsItemList('!IsDefined(StateNaAllocatie1/'+CaseClassifications/StandVar/Path+'[0[CompactedAdminDomain]])')+')';
	parameter<bool> AllDefined   := NOT(AnyUndefined) && FALSE;
	
	container StateNaAllocatie2_zFence :=
		for_each_nedvn(
			CaseClassifications/StandVar/Path
			, 'value(AllDefined['+CaseClassifications/StandVar/value_type+'] + StateNaAllocatie1/'+CaseClassifications/StandVar/Path + ', scope(CaseClassifications/StandVar, '+CaseClassifications/StandVar/unit_name+'))'
			, CompactedAdminDomain
			, CaseClassifications/StandVar
			, CaseClassifications/StandVar/unit_name
		)
	{
		container Wonen
		{
			attribute<Woning> Aantal_Woningen_Totaal (CompactedAdminDomain) := = 'add('+AsItemList(Classifications/Vastgoed/WP2xVSSH/name)+')';
		}
	}
	
	container StateNaAllocatie_zFence := StateNaAllocatie2_zFence;
	container StateNaAllocatie := =ModelParameters/Use_Fence_operator ? 'StateNaAllocatie_metFence' : 'StateNaAllocatie_zFence';
}