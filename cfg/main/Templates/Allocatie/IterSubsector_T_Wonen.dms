Template IterSubsector_T_Wonen
: Descr = "Hier worden de onderdelen voor de subsectoren j bepaald (voor enkel wonen); i.e. beschikbaarheid, suitability S_ij, restclaim C_jr, zaaglijn Z_ij. Voor de wiskundige beschrijving zie de URL."
, URL = "https://github.com/ObjectVision/RSopen/wiki/Allocatie-procedure-in-formules"
{
	//
	parameter<Subsector> id;
	unit<UInt8> Subsector;
	container StateVoorAllocatie;
	container Context0;
	//
	
	container Context := Context0
	{
		container ThisSubsector := ..;
	}
	
	parameter<String> name               := Subsector/name[id];
	parameter<String> Subsector_pathname := Subsector/Sector_name_Thisname[id];
	parameter<String> Zichtjaar_name     := Context/ThisZichtjaar/name;
	parameter<String> AllocRegio_name    := Context/ThisSectorAllocRegio/AllocRegio_name;
	
	unit<UInt32> TredeK        := ='VariantData/Trede/SectorxSubsectoren/'+Subsector_pathname+'/Klasse';
	unit<UInt8>  OP            := CaseClassifications/Vastgoed/OP;
	unit<UInt8>  OP_subdomain  := ='OP/perWP2xVSSH/'+Context/ThisSubsector/name+'/OP_sub';
	unit<UInt8>  OP_sub_NoData := ='OP/perWP2xVSSH/'+Context/ThisSubsector/name+'/OP_sub_NoData';
	
	unit<uint64> CompactedAdminDomain := Geography/CompactedAdminDomain
	, Descr = "Op AdminDomain niveau wordt de geschiktheid en beschikbaarheid opgehaald/bepaald."
	{
		attribute<OP_subdomain> Geschiktheid_ArgMax_OP_sub :=  
			='ArgMax_ifdefined('+asItemList('VariantData/Zeef/'+Zichtjaar_name+'/'+Subsector_pathname+'/Zeef_perOP/'+OP/name[OP_subdomain/org_rel]+'/Beschikbaar_voorOP'
				'? Suitability/'+Zichtjaar_name+'/'+Subsector_pathname+'/perOP/'+OP/name[OP_subdomain/org_rel]+'/TotaalAdminDomain'
				': (0f/0f)'
			)+')[OP_subdomain]', Descr = "Welk OP, wanneer beschikbaar in land unit i, heeft de hoogste suitability S_ij? Dit is gedefinieerd in OP_subdomain, dat is de set van OP die bij de subsector horen die in deze template overwogen.";
			
		attribute<Float32>      Geschiktheid_MaxElem_OP_sub :=
			='max_elem('+asItemList('VariantData/Zeef/'+Zichtjaar_name+'/'+Subsector_pathname+'/Zeef_perOP/'+OP/name[OP_subdomain/org_rel]+'/Beschikbaar_voorOP'
				'? Suitability/'+Zichtjaar_name+'/'+Subsector_pathname+'/perOP/'+OP/name[OP_subdomain/org_rel]+'/TotaalAdminDomain'
				': (0f/0f)'
			)+')', Descr = "Wat is de suitability S_ij die hoort bij het OP die is gevonden in Geschiktheid_ArgMax_OP_sub?";
		
		attribute<OP>           Geschiktheid_ArgMax_OP              := Geschiktheid_ArgMax_OP_sub -> org_rel, Descr = "Vertaling van OP_subdomain naar OP, om te kunnen gebruiken in vergelijking tussen subsectoren.";
		attribute<Bool>         Beschikbaar_OPs                     := = 'OR('+asList('VariantData/Zeef/'+Zichtjaar_name+'/'+Subsector_pathname+'/Zeef_perOP/'+OP_subdomain/name+'/Beschikbaar_voorOP', ',')+')', Descr = "Is land unit i beschikbaar voor tenminste een van alle OPs?";
		attribute<Bool>         Beschikbaar                         := Beschikbaar_OPs && !(IsDefined(StateVoorAllocatie/SubSector_rel)) && !ExtraRestrictieDoorHuidigeZonneweide && !RestrictiesVoorSectorenAlsGevolgVanWind/Restrictief_voor_kwestbare_gebouwen, Descr = "Is land unit i beschikbaar voor een OP en niet al eerder dit of vorige zichtjaren gealloceerd, en niet niet nog een additionele restrictie door wind allocatie?";
		attribute<Float32>      PotentieleStateNaAllocatie          := MakeDefined(OP/Dichtheid[Geschiktheid_ArgMax_OP], 0f) * float32(Beschikbaar) * AdminDomain/NrHaPerCell, Descr = "Zoek bij het OP met die kan en de hoogste S heeft de bijbehorende dichtheid op, check nog eens op beschikbaarheid, en vertaal dichtheid per ha naar AdminDomain naar ", IntegrityCheck = "Check_of_IsBestOPOokDaarBeschikbaar";
		attribute<Bool>         Check_of_IsBestOPOokDaarBeschikbaar := ='IsNull(Geschiktheid_ArgMax_OP_sub)' //of er niks in die cell
																		'|| OR('+asItemList('Geschiktheid_ArgMax_OP_sub == '+string(id(OP_subdomain))+'[OP_subdomain]' //of de gekozen OP mag daar ook.
																				'&& VariantData/Zeef/'+Zichtjaar_name+'/'+Subsector_pathname+'/Zeef_perOP/'+OP_subdomain/name+'/Beschikbaar_voorOP')+')', Descr = "Extra check of voor de gekozen OP die land unit i daadwerkelijk beschikbaar is.";
	}
	
	unit<uint64> CompactedAllocDomain := Geography/CompactedAllocDomain
	, Descr = "Allocatie geschiedt uiteindelijk op AllocDomain, dus hier worden een aantal aggregaties gemaakt."
	{
		attribute<Float32> Geschiktheid_Aggregated    := sum(CompactedAdminDomain/Geschiktheid_MaxElem_OP_sub, CompactedAdminDomain/CompactedAllocDomain_rel), Descr = "Aggregatie van AdminDomain S_ij naar AllocDomain.";
		attribute<Float32> Geschiktheid_Cleaned       := Geschiktheid_Aggregated == 0f ? null_f : Geschiktheid_Aggregated, Descr = "Als de geschiktheid 0 is, willen we dit undefined hebben.";
		attribute<Ha>      HectarenBeschikbaar        := sum(float32(CompactedAdminDomain/Beschikbaar) * CompactedAdminDomain/NrHaPerCell, CompactedAdminDomain/CompactedAllocDomain_rel), Descr = "Aggregatie van beschikbare cellen vanaf AdminDomain naar AllocDomain uitgedrukt in hectare.";
		attribute<UInt32>  Geschiktheid_Ordered       := invert(index(Geschiktheid_Cleaned))[uint32], Descr = "In het allocatie proces moet de geschiktheid gesorteerd worden, zodat er greedy vanaf de meest geschikte locatie gealloceerd wordt.";
		parameter<UInt32>  Geschiktheid_Ordered_range := max(Geschiktheid_Ordered)+100, Descr = "Wat is de maximale geschiktheid, plus een getal wat er voor zorgt dat er later geen dubbele waarden kunnen voorkomen.";
		attribute<UInt32>  TredeScore                 := (#TredeK - 1) - collect_by_cond(CompactedAllocDomain, AllocDomain/IsCompactedDomain, TredeK/Per_AllocDomain)
															, Descr = "Tredes introduceren een volgordelijkheid in groepen cellen. Zodat onafhankelijk van de geschiktheid sommige groepen cellen boven andere geplaatst moeten worden.
																		Bijvoorbeeld dichtbij een OV-knooppunt. Hier wordt deze volgordelijkheid voorbereid. Met een check of de maximale waarde van een trede wel kleiner of gelijk is aan de cardinaliteit van de tredes. Is dit niet het geval, dan moet je meer onderzoek uitvoeren.", IntegrityCheck = "max(collect_by_cond(CompactedAllocDomain, AllocDomain/IsCompactedDomain, TredeK/Per_AllocDomain)) < #TredeK";
		attribute<UInt32>  Geschiktheid_Unchecked     := TredeScore * Geschiktheid_Ordered_range + Geschiktheid_Ordered, Descr = "Hier wordt de sorteerde geschiktheid gecombineerd met de tredescores tot een aangepaste geschiktheid in groepen per trede.";
		attribute<UInt32>  Geschiktheid               := ='HectarenBeschikbaar > VariantParameters/VariantK/MinimalLandAvailability[VariantParameters/VariantK/V/'+Variant_name+'] ? Geschiktheid_Unchecked : null_u', Descr = "Hier wordt nog checkt of er wel voldoende land binnen een AllocDomain cel beschikbaar is, gegeven een variant parameter.";
	
		attribute<Float32> PotentieleStateNaAllocatie := sum(CompactedAdminDomain/PotentieleStateNaAllocatie, CompactedAdminDomain/CompactedAllocDomain_rel), Descr = "Aggregatie van AdminDomain D_ij naar AllocDomain.";
	}
	
	unit<UInt32> AllocRegio := Context/ThisSectorAllocRegio/AllocRegio
	, Descr = ""
	{
		attribute<Float32> RestClaim := = replace( 
			'VariantData/Claims/@Z@/SectorAllocRegios/@AS@/@S@'+AllocRegio_StudyArea_orgrel+' - sum(StateVoorAllocatie/@SP@, Per_CompactedAdminDomain)',
			'@Z@' , Zichtjaar_name,
			'@AS@', Context/ThisSectorAllocRegio/name,
			'@S@' , Context/ThisSubsector/name,
			'@SP@',Subsector_pathname
		), Descr = "Hier de restclaim C_jr bepaald, door van de claim voor deze regio en subsector de stand voor deze allocatie stap af te trekken.";
		
		attribute<Ha>     Beschikbaar           := sum_uint32(CompactedAdminDomain/Beschikbaar, Per_CompactedAdminDomain)[float32] * AdminDomain/NrHaPerCell, Descr = "Aggregatie van beschikbaarheid in AdminDomain middels R_ir uitgedrukt in hectare.";
		attribute<Bool>   GeenRuimteOfRestclaim := Beschikbaar == 0[ha] || RestClaim <= 0[float32], Descr = "Is geen ruimte in deze regio, of er geen of een negatieve restclaim?";
		attribute<UInt32> MaxGeschiktheid       := max(CompactedAllocDomain/Geschiktheid, collect_by_cond(CompactedAllocDomain, AllocDomain/IsCompactedDomain, AllocRegio/Per_AllocDomain))[uint32], Descr = "Wat is de maximale geschiktheid in deze regio?";
		parameter<UInt32> MaxGeschiktheid_value := max(CompactedAllocDomain/Geschiktheid)[uint32], Descr = "Overall maximale geschiktheid.";
		
		attribute<UInt32> Afkapgrens0 := MaxGeschiktheid_value - nth_element_weighted(                // omkering
				MaxGeschiktheid_value - CompactedAllocDomain/Geschiktheid[uint32],                    // rank
				max_elem(RestClaim, 0f),                                                              // target
				CompactedAllocDomain/PotentieleStateNaAllocatie,                                      // weight, hier geen potentiele delta gebruikt; evt sloop van deze subsector heralloceren we in volgende iteraties
				collect_by_cond(CompactedAllocDomain, AllocDomain/IsCompactedDomain, Per_AllocDomain) // R_ir
		), Descr = "hier wordt de zaaglijn Z_ij bepaald.";
		
		attribute<UInt32> Afkapgrens := GeenRuimteOfRestclaim ? null_u : MakeDefined(Afkapgrens0, MaxGeschiktheid), Descr = "Als er uberhaupt geen ruimte of restclaim is voor deze regio, dan mag de zaaglijn undefined zijn. Anders neem je de zaaglijn. Echter, de zaaglijn kan undefined zijn als de niet genoeg cellen beschikbaar zijn om de claim te realisteren. In dat geval wordt de zaagzlijn zo gezet dat alle cellen daarin vallen.";
	}
}