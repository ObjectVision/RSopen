Template IterSubsector_T_Wind
{
	//
	parameter<Subsector> id;
	unit<UInt8> Subsector;
	container StateVoorAllocatie;
	container Context0;
	//
	
	container Context := Context0
	{
		container ThisSubsector := ..;
	}
	
	parameter<String> name               := Subsector/name[id];
	parameter<String> Subsector_pathname := Subsector/Sector_name_Thisname[id];
	parameter<String> Zichtjaar_name     := Context/ThisZichtjaar/name;
	parameter<String> AllocRegio_name    := Context/ThisSectorAllocRegio/AllocRegio_name;
	
	unit<UInt32> TredeK := = 'VariantData/Trede/SectorxSubsectoren/'+Subsector_pathname+'/Klasse';
	
	unit<uint64> CompactedAdminDomain := Geography/CompactedAdminDomain
	, Descr = "Op AdminDomain niveau wordt de geschiktheid en beschikbaarheid opgehaald/bepaald."
	{
		attribute<Bool> Beschikbaar_src                                  := = 'PotentieleState/'+Zichtjaar_name+'/per_SectorxSubsectoren/'+Subsector_pathname+'/IsBeschikbaar_zichtjaar && !(IsDefined(StateVoorAllocatie/SubSector_rel))';
		attribute<Bool> IsNietToegestaan_Dynamisch_PrevSectorAllocRegios := =Context/ThisSectorAllocRegio/name+'/Restricties_Dynamisch_Wind/IsNietToegestaan_Dynamisch';
		attribute<Bool> IsNietToegestaan_Dynamisch_PrevIter              := Restricties_Dynamisch/Bestaande_turbines/IsNietToegestaan;
		attribute<Bool> Beschikbaar                                      := Beschikbaar_src && !IsNietToegestaan_Dynamisch_PrevSectorAllocRegios && !IsNietToegestaan_Dynamisch_PrevIter;
		
		container Restricties_Dynamisch
		{
			// 4.  bestaande turbines --> afstand = 4 * rotordiameter
			container Bestaande_turbines
			{
				parameter<String> Gealloceerd_str := 'StateVoorAllocatie/Wind/Totaal > 0f';
				
				attribute<Bool> Gealloceerd        (CompactedAdminDomain) := =Gealloceerd_str;
				attribute<Bool> Gealloceerd_buffer (CompactedAdminDomain) := Buffer/proximity_res;
				
				container Buffer := Templates/Buffer_gridcel_T(Gealloceerd,  4d * CaseClassifications/WindTurbineType/RotorDiameter[float64]);
				
				attribute<Bool> IsNietToegestaan (CompactedAdminDomain) := Gealloceerd_buffer;
			}
		}
		
		#include<StempelProcedure.dms>
		
		container Results
		{
			parameter<String>                   ArgMax_str        := 'ArgMax('+asList('StempelProcedure/Stempels/'+StempelProcedure/Stempel/name+'/windmolen_grid/locaties_toegestanerijen/AantalLocaties',',')+')[StempelProcedure/Stempel]';
			parameter<StempelProcedure/Stempel> ArgMax            := =ArgMax_str;
			parameter<String>                   BesteStempel_name := StempelProcedure/Stempel/name[ArgMax];
			
			parameter<String> PotentieleStateNaAllocatie_dynamisch := 'StempelProcedure/Stempels/'+Results/BesteStempel_name+'/windmolen_grid/locaties_toegestanerijen/IsBeschikbaar[float32] * CaseClassifications/WindTurbineType/MW_per_turbine';
			parameter<String> PotentieleStateNaAllocatie_statisch  := 'StempelProcedure/Stempels/'+StempelProcedure/Stempel/name[Context/ThisIter/id[StempelProcedure/Stempel]]+'/windmolen_grid/locaties_toegestanerijen/IsBeschikbaar[float32] * CaseClassifications/WindTurbineType/MW_per_turbine';
			parameter<String> PotentieleStateNaAllocatieExpr       := =ModelParameters/Wind/Windpotentie_StempelAan ? 'PotentieleStateNaAllocatie_dynamisch' : 'PotentieleStateNaAllocatie_statisch';
		}
		
		attribute<MW> PotentieleStateNaAllocatie_AdminDomain (AdminDomain) := =Results/PotentieleStateNaAllocatieExpr;
		attribute<MW> PotentieleStateNaAllocatie    (CompactedAdminDomain) := collect_by_cond(CompactedAdminDomain, AdminDomain/IsCompactedDomain, PotentieleStateNaAllocatie_AdminDomain);
		
		attribute<Float32> Geschiktheid_Desaggr       := = 'VariantData/Suitability/'+Context/ThisZichtjaar/name+'/'+Subsector_pathname+'[CompactedAdminDomain/CompactedAllocDomain_rel]';
		attribute<Float32> Geschiktheid_Cleaned       := PotentieleStateNaAllocatie > 0[MW] ? Geschiktheid_Desaggr : null_f, Descr = "Als de geschiktheid 0 is, willen we dit undefined hebben.";
		attribute<UInt32>  Geschiktheid_Ordered       := invert(index(Geschiktheid_Cleaned))[uint32], Descr = "In het allocatie proces moet de geschiktheid gesorteerd worden, zodat er greedy vanaf de meest geschikte locatie gealloceerd wordt.";
		parameter<UInt32>  Geschiktheid_Ordered_range := max(Geschiktheid_Ordered)+100, Descr = "Wat is de maximale geschiktheid, plus een getal wat er voor zorgt dat er later geen dubbele waarden kunnen voorkomen.";
		
		attribute<UInt32>  TredeScore                 := (#TredeK -1) - collect_by_cond(CompactedAdminDomain, AdminDomain/IsCompactedDomain, TredeK/Per_AdminDomain)
															, Descr = "Tredes introduceren een volgordelijkheid in groepen cellen. Zodat onafhankelijk van de geschiktheid sommige groepen cellen boven andere geplaatst moeten worden.
																		Bijvoorbeeld dichtbij een OV-knooppunt. Hier wordt deze volgordelijkheid voorbereid. Met een check of de maximale waarde van een trede wel kleiner of gelijk is aan de cardinaliteit van de tredes. Is dit niet het geval, dan moet je meer onderzoek uitvoeren.", IntegrityCheck = "max(collect_by_cond(CompactedAllocDomain, AllocDomain/IsCompactedDomain, TredeK/Per_AllocDomain)) < #TredeK";
		attribute<Float32> Geschiktheid               := (float32(TredeScore) * float32(Geschiktheid_Ordered_range) + float32(Geschiktheid_Ordered)), Descr = "Hier wordt de sorteerde geschiktheid gecombineerd met de tredescores tot een aangepaste geschiktheid in groepen per trede.";
	}
	
	unit<UInt32> AllocRegio := Context/ThisSectorAllocRegio/AllocRegio
	, Descr = ""
	{
		attribute<Float32> RestClaim := = replace(
			'VariantData/Claims/@Z@/SectorAllocRegios/@AS@/@S@'+AllocRegio_StudyArea_orgrel+' - sum(StateVoorAllocatie/@SP@, Per_CompactedAdminDomain)',
			'@Z@' , Zichtjaar_name,
			'@AS@', Context/ThisSectorAllocRegio/name,
			'@S@' , Context/ThisSubsector/name,
			'@SP@', Subsector_pathname
		), Descr = "Hier de restclaim C_jr bepaald, door van de claim voor deze regio en subsector de stand voor deze allocatie stap af te trekken.";
		
		attribute<Ha>     Beschikbaar           := sum_uint32(CompactedAdminDomain/Beschikbaar, Per_CompactedAdminDomain)[float32] * AdminDomain/NrHaPerCell, Descr = "Aggregatie van beschikbaarheid in AdminDomain middels R_ir uitgedrukt in hectare.";
		attribute<Bool>   GeenRuimteOfRestclaim := Beschikbaar == 0[ha] || RestClaim <= 0[float32], Descr = "Is geen ruimte in deze regio, of er geen of een negatieve restclaim?";
		attribute<uint64> MaxGeschiktheid       := max(CompactedAdminDomain/Geschiktheid, AllocRegio/Per_CompactedAdminDomain)[uint64], Descr = "Wat is de maximale geschiktheid in deze regio?";
		attribute<uint64> MinGeschiktheid       := min(CompactedAdminDomain/Geschiktheid, AllocRegio/Per_CompactedAdminDomain)[uint64];
		
		parameter<uint64> MaxGeschiktheid_value := max(CompactedAdminDomain/Geschiktheid)[uint64], Descr = "Overall maximale geschiktheid.";
		
		attribute<uint64> Afkapgrens0 := sub_or_null(MaxGeschiktheid_value, nth_element_weighted(  //omkering
				MaxGeschiktheid_value - CompactedAdminDomain/Geschiktheid[uint64],                 // rank
				max_elem(RestClaim, 0f),                                                           // target
				CompactedAdminDomain/PotentieleStateNaAllocatie,                                   // weight, hier geen potentiele delta gebruikt; evt sloop van deze subsector heralloceren we in volgende iteraties
				Per_CompactedAdminDomain                                                           // R_ir
		)), Descr = "hier wordt de zaaglijn Z_ij bepaald.";
	
		attribute<uint64> Afkapgrens := GeenRuimteOfRestclaim ? null_u64 : MakeDefined(Afkapgrens0, sub_or_null(MinGeschiktheid,1u64)), Descr = "Als er uberhaupt geen ruimte of restclaim is voor deze regio, dan mag de zaaglijn undefined zijn. Anders neem je de zaaglijn. Echter, de zaaglijn kan undefined zijn als de niet genoeg cellen beschikbaar zijn om de claim te realisteren. In dat geval wordt de zaagzlijn zo gezet dat alle cellen daarin vallen.";
	}
}