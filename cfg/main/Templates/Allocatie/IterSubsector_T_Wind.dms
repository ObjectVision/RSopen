Template IterSubsector_T_Wind
: Descr = "Template voor een subsector binnen een iteratie van een allocatieproces, specifiek voor wind."
{
	parameter<Subsector> id;
	unit<UInt8> Subsector;
	container StateVoorAllocatie;
	container Context0;
	//
	
	container Context := Context0
	{
		container ThisSubsector := ..;
	}
	
	parameter<String> name               := Subsector/name[id];
	parameter<String> Subsector_pathname := Subsector/Sector_name_Thisname[id];
	parameter<String> Zichtjaar_name     := Context/ThisZichtjaar/name;
	parameter<String> AllocRegio_name    := Context/ThisSectorAllocRegio/AllocRegio_name;
	
	unit<UInt32> TredeK := = 'VariantData/Trede/SectorxSubsectoren/'+Subsector_pathname+'/impl/Klasse';
	
	unit<uint64> CompactedAdminDomain := Geography/CompactedAdminDomain
	, Descr = "Op AdminDomain niveau wordt de geschiktheid en beschikbaarheid opgehaald/bepaald."
	{
		attribute<Bool> Beschikbaar_src                                  := = 'PotentieleState/'+Zichtjaar_name+'/per_SectorxSubsectoren/'+Subsector_pathname+'/IsBeschikbaar_zichtjaar && !(IsDefined(StateVoorAllocatie/SubSector_rel))', Descr = "Is de cel potentieel beschikbaar voor deze subsector in dit zichtjaar, en is er nog niets gealloceerd in een eerdere iteratie?";
		attribute<Bool> IsNietToegestaan_Dynamisch_PrevSectorAllocRegios := =Context/ThisSectorAllocRegio/name+'/Restricties_Dynamisch_Wind/IsNietToegestaan_Dynamisch', Descr = "Is er in een voorgaande sector alloc regio iets gealloceerd waardoor er nu geen wind meer toegestaan is?";
		attribute<Bool> IsNietToegestaan_Dynamisch_PrevIter              := Restricties_Dynamisch/Bestaande_turbines/IsNietToegestaan, Descr = "Is er in een voorgaande iteratie iets gealloceerd waardoor er nu geen wind meer toegestaan is?";
		attribute<Bool> Beschikbaar                                      := Beschikbaar_src && !IsNietToegestaan_Dynamisch_PrevSectorAllocRegios && !IsNietToegestaan_Dynamisch_PrevIter, Descr = "Is de cel beschikbaar voor allocatie in deze iteratie?";
		
		container Restricties_Dynamisch
		{
			// 4.  bestaande turbines --> afstand = 4 * rotordiameter
			container Bestaande_turbines
			{
				attribute<bool>      IsNietToegestaan (CompactedAdminDomain) := IsDefined(collect_by_cond(CompactedAdminDomain, AdminDomain/IsCompactedDomain, poly2grid(WindCellen/buffer, AdminDomain)));
				
				unit<uint64> WindCellen := select_with_org_rel(recollect_by_cond(AdminDomain/IsCompactedDomain, StateVoorAllocatie/Wind/Totaal > 0f))
				{
					attribute<rdc_meter> geometry          := org_rel[rdc_meter];
					attribute<Meter>     Ashoogte          := recollect_by_cond(AdminDomain/IsCompactedDomain, StateVoorAllocatie/Wind/Ashoogte)[org_rel];
					attribute<Meter>     Rotordiameter     := recollect_by_cond(AdminDomain/IsCompactedDomain, StateVoorAllocatie/Wind/Rotordiameter)[org_rel];
					attribute<Meter>     MaxWerpAfstandNom := recollect_by_cond(AdminDomain/IsCompactedDomain, StateVoorAllocatie/Wind/MaxWerpAfstandNom)[org_rel];
					
					attribute<float64>   buffer_size       := MakeDefined(ModelParameters/Wind/AantalKeerWerpafstandRestrictieHuidigeTurbines[float64] * RotorDiameter[float64], ModelParameters/Wind/AantalKeerWerpafstandRestrictieHuidigeTurbines[float64] * Ashoogte[float64]);
					attribute<rdc_meter> buffer     (poly) := bg_buffer_point(geometry, buffer_size, 16b), Descr = "Buffer rond bestaande turbines, waarbinnen geen nieuwe turbines geplaatst mogen worden.";
				}
			}
		}
		
		#include<StempelProcedure.dms>
		
		container Results
		{
			parameter<String>                   ArgMax_str        := 'ArgMax('+asList('StempelProcedure/Stempels/'+StempelProcedure/Stempel/name+'/windmolen_grid/locaties_toegestanerijen/AantalLocaties',',')+')[StempelProcedure/Stempel]', Descr = "Welke stempel heeft de meeste locaties toegewezen gekregen?";
			parameter<StempelProcedure/Stempel> ArgMax            := =ArgMax_str;
			parameter<String>                   BesteStempel_name := StempelProcedure/Stempel/name[ArgMax], Descr = "Wat is de naam van de stempel met de meeste toegewezen locaties?";
			
			parameter<String> PotentieleStateNaAllocatie_dynamisch := 'StempelProcedure/Stempels/'+Results/BesteStempel_name+'/windmolen_grid/locaties_toegestanerijen/IsBeschikbaar[float32] * CaseClassifications/WindTurbineType/MW_per_turbine', Descr = "Wat is de potentiele state na allocatie, als er met dynamische stempels gewerkt wordt?";
			parameter<String> PotentieleStateNaAllocatie_statisch  := 'StempelProcedure/Stempels/'+StempelProcedure/Stempel/name[Context/ThisIter/id[StempelProcedure/Stempel]]+'/windmolen_grid/locaties_toegestanerijen/IsBeschikbaar[float32] * CaseClassifications/WindTurbineType/MW_per_turbine', Descr = "Wat is de potentiele state na allocatie, als er met statische stempels gewerkt wordt?";
			parameter<String> PotentieleStateNaAllocatieExpr       := =ModelParameters/Wind/Windpotentie_StempelAan ? 'PotentieleStateNaAllocatie_dynamisch' : 'PotentieleStateNaAllocatie_statisch', Descr = "Welke van de twee methoden wordt gebruikt om de potentiele state na allocatie te bepalen.";
		}
		
		attribute<MW> PotentieleStateNaAllocatie_AdminDomain (AdminDomain) := =Results/PotentieleStateNaAllocatieExpr;
		attribute<MW> PotentieleStateNaAllocatie    (CompactedAdminDomain) := collect_by_cond(CompactedAdminDomain, AdminDomain/IsCompactedDomain, PotentieleStateNaAllocatie_AdminDomain), Descr = "Wat is de potentiele state na allocatie in MW per CompactedAdminDomain.";
		
		attribute<Float32> Geschiktheid_Desaggr       := = 'VariantData/Suitability/'+Context/ThisZichtjaar/name+'/'+Subsector_pathname+'[CompactedAdminDomain/CompactedAllocDomain_rel]', Descr = "De geschiktheid voor deze subsector in dit zichtjaar, op CompactedAllocDomain niveau.";
		attribute<Float32> Geschiktheid_Cleaned       := PotentieleStateNaAllocatie > 0[MW] ? Geschiktheid_Desaggr : null_f, Descr = "Als de geschiktheid 0 is, willen we dit undefined hebben.";
		attribute<UInt32>  Geschiktheid_Ordered       := invert(index(Geschiktheid_Cleaned))[uint32], Descr = "In het allocatie proces moet de geschiktheid gesorteerd worden, zodat er greedy vanaf de meest geschikte locatie gealloceerd wordt.";
		parameter<UInt32>  Geschiktheid_Ordered_range := max(Geschiktheid_Ordered)+100, Descr = "Wat is de maximale geschiktheid, plus een getal wat er voor zorgt dat er later geen dubbele waarden kunnen voorkomen.";
		
		attribute<UInt32>  TredeScore                 := (#TredeK -1) - collect_by_cond(CompactedAdminDomain, AdminDomain/IsCompactedDomain, TredeK/Per_AdminDomain)
															, Descr = "Tredes introduceren een volgordelijkheid in groepen cellen. Zodat onafhankelijk van de geschiktheid sommige groepen cellen boven andere geplaatst moeten worden.
																		Bijvoorbeeld dichtbij een OV-knooppunt. Hier wordt deze volgordelijkheid voorbereid. Met een check of de maximale waarde van een trede wel kleiner of gelijk is aan de cardinaliteit van de tredes. Is dit niet het geval, dan moet je meer onderzoek uitvoeren.", IntegrityCheck = "max(collect_by_cond(CompactedAllocDomain, AllocDomain/IsCompactedDomain, TredeK/Per_AllocDomain)) < #TredeK";
		attribute<Float32> Geschiktheid               := (float32(TredeScore) * float32(Geschiktheid_Ordered_range) + float32(Geschiktheid_Ordered)), Descr = "Hier wordt de sorteerde geschiktheid gecombineerd met de tredescores tot een aangepaste geschiktheid in groepen per trede.";
	}
	
	unit<UInt32> AllocRegio := Context/ThisSectorAllocRegio/AllocRegio
	, Descr = ""
	{
		attribute<Float32> RestClaim := = replace(
			'VariantData/Claims/@Z@/SectorAllocRegios/@AS@/@S@'+AllocRegio_StudyArea_orgrel+' - sum(StateVoorAllocatie/@SP@, Per_CompactedAdminDomain)',
			'@Z@' , Zichtjaar_name,
			'@AS@', Context/ThisSectorAllocRegio/name,
			'@S@' , Context/ThisSubsector/name,
			'@SP@', Subsector_pathname
		), Descr = "Hier de restclaim C_jr bepaald, door van de claim voor deze regio en subsector de stand voor deze allocatie stap af te trekken.";
		
		attribute<Ha>     Beschikbaar           := sum_uint32(CompactedAdminDomain/Beschikbaar, Per_CompactedAdminDomain)[float32] * AdminDomain/NrHaPerCell, Descr = "Aggregatie van beschikbaarheid in AdminDomain middels R_ir uitgedrukt in hectare.";
		attribute<Bool>   GeenRuimteOfRestclaim := Beschikbaar == 0[ha] || RestClaim <= 0[float32], Descr = "Is geen ruimte in deze regio, of er geen of een negatieve restclaim?";
		attribute<uint64> MaxGeschiktheid       := max(CompactedAdminDomain/Geschiktheid, AllocRegio/Per_CompactedAdminDomain)[uint64], Descr = "Wat is de maximale geschiktheid in deze regio?";
		attribute<uint64> MinGeschiktheid       := min(CompactedAdminDomain/Geschiktheid, AllocRegio/Per_CompactedAdminDomain)[uint64];
		
		parameter<uint64> MaxGeschiktheid_value := max(CompactedAdminDomain/Geschiktheid)[uint64], Descr = "Overall maximale geschiktheid.";
		
		attribute<uint64> Afkapgrens0 := sub_or_null(MaxGeschiktheid_value, nth_element_weighted(  //omkering
				MaxGeschiktheid_value - CompactedAdminDomain/Geschiktheid[uint64],                 // rank
				max_elem(RestClaim, 0f),                                                           // target
				CompactedAdminDomain/PotentieleStateNaAllocatie,                                   // weight, hier geen potentiele delta gebruikt; evt sloop van deze subsector heralloceren we in volgende iteraties
				Per_CompactedAdminDomain                                                           // R_ir
		)), Descr = "hier wordt de zaaglijn Z_ij bepaald.";
	
		attribute<uint64> Afkapgrens := GeenRuimteOfRestclaim ? null_u64 : MakeDefined(Afkapgrens0, sub_or_null(MinGeschiktheid,1u64)), Descr = "Als er uberhaupt geen ruimte of restclaim is voor deze regio, dan mag de zaaglijn undefined zijn. Anders neem je de zaaglijn. Echter, de zaaglijn kan undefined zijn als de niet genoeg cellen beschikbaar zijn om de claim te realisteren. In dat geval wordt de zaagzlijn zo gezet dat alle cellen daarin vallen.";
	}
}