Template Iter_T
{
	//
	parameter<Iter> id;
	container StateVoorAllocatie;
	container Context0;
	unit<uint8> Iter; //IterK
	container Impl0;
	parameter<bool> IsEnkelIter;
	//
	
	parameter<string> name := Iter/name[id];
	
	container Context := Context0
	{
		container ThisIter := ..;
		parameter<string> ThisItername := Iter/name[id];
		parameter<string> PrevItername := Iter/PrevName[id];
	}
	
	unit<uint8>  Subsector  := Context/ThisSectorAllocRegio/Subsector;
	unit<uint32> AllocRegio := Context/ThisSectorAllocRegio/AllocRegio;
	unit<uint8>  OP         := CaseClassifications/Vastgoed/OP;
	
	// Er zijn drie soorten IterSubsector templates, omdat voor wonen er een module over OP's nodig is, voor wind een deel over stempels, en voor de overige sectoren is het wel generiek.
	container Subsectoren :=
		for_each_ne(
			 Subsector/name
			,lowercase(Sector_name) == lowercase('Wonen')
				? 'IterSubsector_T_Wonen('+string(id(Subsector))+'[Subsector],Subsector,StateVoorAllocatie,Context)'
				: lowercase(Sector_name) == lowercase('Wind')
					? 'IterSubsector_T_Wind('+string(id(Subsector))+'[Subsector],Subsector,StateVoorAllocatie,Context)'
					: 'IterSubsector_T('+string(id(Subsector))+'[Subsector],Subsector,StateVoorAllocatie,Context)'
	);
	
	#include<Iter_Allocatie.dms>
	
	attribute<bool> IsNuGealloceerd (CompactedAdminDomain) := IsDefined(Allocatie/per_SectorxSubsector);
	
	container Impl := Impl0
	{
		// parameter<bool> HasNoAllocInCurrentIter := NOT(any(!IsDefined(StateVoorAllocatie/SubSector_rel) && IsDefined(StateNaAllocatie/SubSector_rel)));
		// parameter<bool> HasNoRestClaim := RestClaim_NaAlloc == 0f;
		
		// parameter<string> RestClaim_NaAlloc_str := AsList(
			// replace(
			// 'abs(sum(VariantData/Claims/@Z@/SectorAllocRegios/@AS@/@S@) - sum(StateNaAllocatie/@SP@))',
			// '@Z@' , Context/ThisZichtjaar/name,
			// '@AS@', Context/ThisSectorAllocRegio/name,
			// '@S@', Subsector/name,
			// '@SP@', Subsector/Sector_name_Thisname
			// )
		// , ' + ');
		
		// parameter<float32> RestClaim_NaAlloc := =RestClaim_NaAlloc_str;
		
		// parameter<string> StopCriterium_NoAlloc    := 'any(HasNoAllocInCurrentIter)';
		// parameter<string> StopCriterium_NoClaim    := 'HasNoRestClaim';
		// parameter<bool>   PrevStop                 := = lowercase(Context/PrevItername) == lowercase('Start') ? 'FALSE' : Context/PrevItername+'/Impl/StopCriterium';
		// parameter<string> DynamicStopCriterium_str := PrevStop ? 'TRUE' : StopCriterium_NoClaim +' || '+StopCriterium_NoAlloc;
		// parameter<bool>   DynamicStopCriterium     := = DynamicStopCriterium_str;
		// parameter<bool>   StopCriterium            := DynamicStopCriterium;
			
	
		parameter<bool> StopCriterium       := StaticStopCriterium;
		parameter<bool> StaticStopCriterium := IsEnkelIter ? TRUE : id == (ModelParameters/Default_NrOfIters - 1b)[Iter];
	}
	
	container StateNaAllocatie0 := 
		for_each_ne(
			Sector/xSubsector/name
			, 'StatePrep_T('+string(id(Sector/xSubsector))+'[Sector/xSubsector], Context/ThisIter)'
		)
	{
		container PandFootprint :=
			for_each_nedv(
				Jobs6/name
				, lowercase(Sector_name) == lowercase('Werken') ? replace(Impl/Update_PandFootprint_Expr,'@Y@', Context/ThisZichtjaar/name, '@SS@', Jobs6/name): replace(Impl/Verdring_Expr, '@S@', 'PandFootprint', '@SS@', Jobs6/name)
				, CompactedAdminDomain
				, m2PandFootprint
			);
	}
	
	container StateNaAllocatie1 :=
		for_each_neidv(
			Sector/xSubsector/name
			, 'StateNaAllocatie0/'+Sector/xSubsector/name+'/Result'
			, 'IsDefined(StateNaAllocatie0/'+Sector/xSubsector/name+'/Result)'
			, CompactedAdminDomain
			, float32
		)
	{
		attribute<Sector/xSubsector> SubSector_rel (CompactedAdminDomain) := MakeDefined(StateVoorAllocatie/SubSector_rel, Allocatie/per_SectorxSubsector);
		attribute<OP>                OP_rel        (CompactedAdminDomain) := MakeDefined(StateVoorAllocatie/OP_rel       , Allocatie/per_OP);
		
		container PandFootprint :=
			for_each_nedv(
				Jobs6/name
				, 'StateNaAllocatie0/PandFootprint/'+Jobs6/name
				, CompactedAdminDomain
				, m2PandFootprint
			);
		
		container Wind
		{
			attribute<Yr> jaartal_ingebruikname (CompactedAdminDomain) := Allocatie/per_SectorxSubsector == Classifications/Actor/Sector/xSubsector/V/Wind_Totaal ? uint16(right(Context/ThisZichtjaar/name,4))[Yr] : StateVoorAllocatie/Wind/jaartal_ingebruikname;
		}
	}

	container StateNaAllocatie2 :=
		for_each_nedvn(
			CaseClassifications/StandVar/Path
			, 'value(StateNaAllocatie1/'+CaseClassifications/StandVar/Path + ', scope(CaseClassifications/StandVar, '+CaseClassifications/StandVar/unit_name+'))'
			, CompactedAdminDomain
			, CaseClassifications/StandVar
			, CaseClassifications/StandVar/unit_name
		)
	{
		container Wonen
		{
			attribute<Woning> Aantal_Woningen_Totaal (CompactedAdminDomain) := = 'add('+AsItemList(Classifications/Vastgoed/WP2xVSSH/name)+')';
		}
	}
	
	container StateNaAllocatie := PhaseContainer(StateNaAllocatie2, 'Results for '+Context/ThisSequencename+', '+Context/ThisSectorAllocRegioname+', '+Context/ThisItername+' are finished calculating');
	

	container Stand_PerAllocRegio := 
		for_each_nedvn(
			CaseClassifications/StandVar/Path
			, 'sum(StateNaAllocatie/'+CaseClassifications/StandVar/Path+', AllocRegio/Per_CompactedAdminDomain)'
			, AllocRegio
			, CaseClassifications/StandVar
			, CaseClassifications/StandVar/unit_name
		)
	{
		container wonen
		{
			attribute<Woning> Aantal_Woningen_Totaal (AllocRegio) := = 'add('+AsItemList(Classifications/Vastgoed/WP2xVSSH/name)+')';
		}
	}
}
