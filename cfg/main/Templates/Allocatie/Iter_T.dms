Template Iter_T
: Descr = "Template voor een iteratie binnen een allocatieproces."
{
	parameter<Iter> id : Descr = "Het iteratienummer, beginnend bij 0.";
	container StateVoorAllocatie : Descr = "container met stand variabelen aan het begin van de allocatie in deze iteratie.";
	container Context0 : Descr = "Context van de iteratie, met daarin de ThisIter container die naar deze Iter verwijst.";
	unit<UInt8> Iter : Descr = "unit met iters";
	container Impl0 : Descr = "container met implementatiegegevens voor de iteratie.";
	parameter<Bool> IsEnkelIter : Descr = "Is dit een enkelvoudige iteratie, dus zonder vervolg iteraties.";
	//
	
	parameter<String> name := Iter/name[id];
	
	container StartCalc0 : Descr = "Constructie voor PhaseContainers, deze string naam wordt dat 'gestart' alvorens iets anders te doen, en pas wanneer voorgaande stappen afgerond zijn."
	{parameter<String> IterName := Context/ThisZichtjaar_name+', '+Context/ThisSequencename+', '+Context/ThisSectorAllocRegioname+', '+Context/ThisItername;}
	container StartCalc := PhaseContainer(StartCalc0, 'Start calculating results for '+StartCalc0/IterName);

	container Context := Context0
	{
		container ThisIter := ..;
		parameter<String> ThisItername := Iter/name[id];
		parameter<String> PrevItername := Iter/PrevName[id];
	}
	
	unit<UInt8>  Subsector  := Context/ThisSectorAllocRegio/Subsector;
	unit<UInt32> AllocRegio := Context/ThisSectorAllocRegio/AllocRegio;
	unit<UInt8>  OP         := CaseClassifications/Vastgoed/OP;
	
	container Subsectoren :=
		for_each_ne(
			 Subsector/name
			,lowercase(Sector_name) == lowercase('Wonen')
				? 'IterSubsector_T_Wonen('+string(id(Subsector))+'[Subsector],Subsector,StateVoorAllocatie,Context)'
				: lowercase(Sector_name) == lowercase('Wind')
					? 'IterSubsector_T_Wind('+string(id(Subsector))+'[Subsector],Subsector,StateVoorAllocatie,Context)'
					: 'IterSubsector_T('+string(id(Subsector))+'[Subsector],Subsector,StateVoorAllocatie,Context)'
	), Descr = "Er zijn drie soorten IterSubsector templates, omdat voor wonen er een module over OP's nodig is, voor wind een deel over stempels, en voor de overige sectoren is het wel generiek.";
	
	#include<Iter_Allocatie.dms>
	
	attribute<Bool> IsNuGealloceerd (CompactedAdminDomain) := IsDefined(Allocatie/per_SectorxSubsector), Descr = "Geeft aan of er in deze iteratie voor deze cel iets gealloceerd is.";
	
	container Impl := Impl0
	{
		// parameter<Bool> HasNoAllocInCurrentIter := NOT(any(!IsDefined(StateVoorAllocatie/SubSector_rel) && IsDefined(StateNaAllocatie/SubSector_rel)));
		// parameter<Bool> HasNoRestClaim := RestClaim_NaAlloc == 0f;
		
		// parameter<String> RestClaim_NaAlloc_str := asList(
			// replace(
			// 'abs(sum(VariantData/Claims/@Z@/SectorAllocRegios/@AS@/@S@) - sum(StateNaAllocatie/@SP@))',
			// '@Z@' , Context/ThisZichtjaar/name,
			// '@AS@', Context/ThisSectorAllocRegio/name,
			// '@S@', Subsector/name,
			// '@SP@', Subsector/Sector_name_Thisname
			// )
		// , ' + ');
		
		// parameter<Float32> RestClaim_NaAlloc := =RestClaim_NaAlloc_str;
		
		// parameter<String> StopCriterium_NoAlloc    := 'any(HasNoAllocInCurrentIter)';
		// parameter<String> StopCriterium_NoClaim    := 'HasNoRestClaim';
		// parameter<Bool>   PrevStop                 := = lowercase(Context/PrevItername) == lowercase('Start') ? 'FALSE' : Context/PrevItername+'/Impl/StopCriterium';
		// parameter<String> DynamicStopCriterium_str := PrevStop ? 'TRUE' : StopCriterium_NoClaim +' || '+StopCriterium_NoAlloc;
		// parameter<Bool>   DynamicStopCriterium     := = DynamicStopCriterium_str;
		// parameter<Bool>   StopCriterium            := DynamicStopCriterium;
			
	
		parameter<Bool> StopCriterium       := StaticStopCriterium;
		parameter<Bool> StaticStopCriterium := IsEnkelIter ? TRUE : id == (ModelParameters/Default_NrOfIters - 1b)[Iter];
	}
	
	container StateNaAllocatie0 := 
		for_each_ne(
			Sector/xSubsector/name
			, 'StatePrep_T('+string(id(Sector/xSubsector))+'[Sector/xSubsector], Context/ThisIter)'
		), Descr = "Voorbereiden van de stand variabelen na allocatie, door de waarden uit de stand variabelen voor allocatie over te nemen."
	{
		container PandFootprint :=
			for_each_nedv(
				Jobs6/name
				, lowercase(Sector_name) == lowercase('Werken') ? replace(Impl/Update_PandFootprint_Expr,'@Y@', Context/ThisZichtjaar/name, '@SS@', Jobs6/name): replace(Impl/Verdring_Expr, '@S@', 'PandFootprint', '@SS@', Jobs6/name)
				, CompactedAdminDomain
				, m2PandFootprint
			);
	}
	
	container StateNaAllocatie1 :=
		for_each_neidv(
			Sector/xSubsector/name
			, 'StateNaAllocatie0/'+Sector/xSubsector/name+'/Result'
			, 'IsDefined(StateNaAllocatie0/'+Sector/xSubsector/name+'/Result)'
			, CompactedAdminDomain
			, float32
		), Descr = "De resultaten van de verschillende subsectoren worden samengevoegd in één container. Als er voor een subsector niets gealloceerd is, bestaat die container niet en wordt die dus ook niet meegenomen."
	{
		attribute<Sector/xSubsector> SubSector_rel (CompactedAdminDomain) := MakeDefined(StateVoorAllocatie/SubSector_rel, Allocatie/per_SectorxSubsector);
		attribute<OP>                OP_rel        (CompactedAdminDomain) := MakeDefined(StateVoorAllocatie/OP_rel       , Allocatie/per_OP);
		
		container PandFootprint :=
			for_each_nedv(
				Jobs6/name
				, 'StateNaAllocatie0/PandFootprint/'+Jobs6/name
				, CompactedAdminDomain
				, m2PandFootprint
			);
		
		container Wind
		{
			attribute<Yr>    Jaartal_ingebruikname (CompactedAdminDomain) := =VariantParameters/SectorAllocRegio/Uq_Sectors/HasWindSector ? 'Allocatie/per_SectorxSubsector == Sector/xSubsector/V/Wind_Totaal ? UInt16(right(Context/ThisZichtjaar/name,4))[Yr] : StateVoorAllocatie/Wind/jaartal_ingebruikname' : 'StateVoorAllocatie/Wind/jaartal_ingebruikname';
			attribute<Meter> Ashoogte              (CompactedAdminDomain) := =VariantParameters/SectorAllocRegio/Uq_Sectors/HasWindSector ? 'Allocatie/per_SectorxSubsector == Sector/xSubsector/V/Wind_Totaal ? /CaseClassifications/WindTurbineType/Ashoogte : StateVoorAllocatie/Wind/Ashoogte' : 'StateVoorAllocatie/Wind/Ashoogte';
			attribute<Meter> Rotordiameter         (CompactedAdminDomain) := =VariantParameters/SectorAllocRegio/Uq_Sectors/HasWindSector ? 'Allocatie/per_SectorxSubsector == Sector/xSubsector/V/Wind_Totaal ? /CaseClassifications/WindTurbineType/Rotordiameter : StateVoorAllocatie/Wind/Rotordiameter' : 'StateVoorAllocatie/Wind/Rotordiameter';
			attribute<Meter> MaxWerpAfstandNom     (CompactedAdminDomain) := =VariantParameters/SectorAllocRegio/Uq_Sectors/HasWindSector ? 'Allocatie/per_SectorxSubsector == Sector/xSubsector/V/Wind_Totaal ? /CaseClassifications/WindTurbineType/MaxWerpAfstandNom : StateVoorAllocatie/Wind/MaxWerpAfstandNom' : 'StateVoorAllocatie/Wind/MaxWerpAfstandNom';
		}
	}

	container StateNaAllocatie2 :=
		for_each_nedvn(
			CaseClassifications/StandVar/Path
			, 'value(StateNaAllocatie1/'+CaseClassifications/StandVar/Path + ', scope(CaseClassifications/StandVar, '+CaseClassifications/StandVar/unit_name+'))'
			, CompactedAdminDomain
			, CaseClassifications/StandVar
			, CaseClassifications/StandVar/unit_name
		), Descr = "De stand variabelen na allocatie worden klaargezet in de juiste eenheden en met de juiste namen."
	{
		container Wonen
		{
			attribute<Woning> Aantal_Woningen_Totaal (CompactedAdminDomain) := =/VariantParameters/SectorAllocRegio/Uq_Sectors/HasWonenSector ? 'add('+asItemList(Classifications/Vastgoed/WP2xVSSH/name)+')' : 'const(0[woning], CompactedAdminDomain)';
		}
	}
	
	container StateNaAllocatie := PhaseContainer(StateNaAllocatie2, 'Results for '+string(StartCalc/IterName)+' are finished calculating');

	container Stand_PerAllocRegio := 
		for_each_nedvn(
			CaseClassifications/StandVar/Path
			, 'sum(StateNaAllocatie/'+CaseClassifications/StandVar/Path+', AllocRegio/Per_CompactedAdminDomain)'
			, AllocRegio
			, CaseClassifications/StandVar
			, CaseClassifications/StandVar/unit_name
		), Descr = "De stand variabelen na allocatie worden opgeteld per allocatieregio."
	{
		container wonen
		{
			attribute<Woning> Aantal_Woningen_Totaal (AllocRegio) := = 'add('+asItemList(Classifications/Vastgoed/WP2xVSSH/name)+')';
		}
	}
	
	container ClaimRealisatieNaAlloc := 
		for_each_nedv(
			Actor/Sector/xSubsector/StandVar_Path
			, replace(
				'Stand_PerAllocRegio/@SP@ / VariantData/Claims/@Z@/SectorAllocRegios/@AS@/@S@'+AllocRegio_StudyArea_orgrel+'',
				'@Z@' , Context/ThisZichtjaar_name,
				'@AS@', Context/ThisSectorAllocRegio/name,
				'@S@' , Actor/Sector/xSubsector/Subsector_name,
				'@SP@', Actor/Sector/xSubsector/StandVar_Path)
			, AllocRegio
			, Float32
		); 
}
