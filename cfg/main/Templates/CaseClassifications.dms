template CaseClassificationsT : using = "Classifications/modellering"
{
	//
	parameter<string> Scenario_name;
	parameter<string> Variant_name;
	//
	
	// BEGIN casus specific, overrule in vergelijk.dms; don't use in prepare.dms
	#include<Actor.dms>
	
	unit<uint32> AllCases := combine(ScenarioK, VariantParameters/VariantK)
	{
		attribute<string> Scenario_name := ScenarioK/name[first_rel];
		attribute<string> Variant_name := VariantParameters/VariantK/name[second_rel];
		attribute<string> name := Scenario_name+'/'+Variant_name;
		attribute<string> Label := Scenario_name+'_'+Variant_name, DialogType = "LabelText";
	}
	
	unit<uint32> ZichtjaarxTXLClaims := combine(Time/Zichtjaar, TigrisXL/Claims)
	{
		attribute<string> Zichtjaar_name := Time/Zichtjaar/name[first_rel];
		attribute<string> TXLClaims_name := TigrisXL/Claims/name[second_rel];
		attribute<string> TXLClaims_ref  := TigrisXL/Claims/TigrisXL_Table_ref[second_rel];
		attribute<string> Label          := Zichtjaar_name+'_'+TXLClaims_name, DialogType = "LabelText";
		attribute<string> name           := Zichtjaar_name+'/'+TXLClaims_name;
	}
	
	unit<uint32> ZichtjaarxTXLClaimsxCase := combine(ZichtjaarxTXLClaims, AllCases)
	{
		attribute<string> Zichtjaar_name   := ZichtjaarxTXLClaims/Zichtjaar_name[first_rel];
		attribute<string> TXLClaims_name   := ZichtjaarxTXLClaims/TXLClaims_name[first_rel];
		attribute<string> Attr_ref         := TigrisXL/Claims/Attr_ref[ZichtjaarxTXLClaims/second_rel[first_rel]];
		attribute<string> Sector_name      := lowercase(TXLClaims_name) == lowercase('banen') ? 'Werken' : 'Wonen';
		attribute<string> TargetValUnitRef := TigrisXL/Claims/TargetValUnitRef[ZichtjaarxTXLClaims/second_rel[first_rel]];
		attribute<string> TXLClaims_ref    := ZichtjaarxTXLClaims/TXLClaims_ref[first_rel];
		attribute<string> Scenario_name    := AllCases/Scenario_name[second_rel];
		attribute<string> Variant_name     := AllCases/Variant_name[second_rel];
		attribute<string> name             := Zichtjaar_name+'/'+TXLClaims_name+'/'+Scenario_name+'/'+Variant_name;
		attribute<string> Label            := Zichtjaar_name+'_'+TXLClaims_name+'_'+Scenario_name+'_'+Variant_name, DialogType = "LabelText";
	}
	
	unit<uint32> StandVar_rels := range(uint32, 0, 2)
	{
		attribute<string> name                 : ['SubSector_rel','OP_rel'];
		attribute<string> Subsector_name       : ['',''];
		attribute<string> path                 : ['SubSector_rel','OP_rel'];
		attribute<string> unit_name            : ['Subsector','OP'];
		attribute<string> value_Type           : ['uint32','uint8'];
		attribute<bool>   HasClaims            : [FALSE, FALSE];
		attribute<bool>   HasAlloc             : [FALSE, FALSE];
		attribute<bool>   IsVastgoed           : [FALSE, FALSE];
		attribute<bool>   UseForLeegstandCorr  : [FALSE, FALSE];
	}
	unit<uint32> StandVar_Prep  := Classifications/Modellering/StandVar_Prep;
	unit<uint32> DeltaVar_Prep  := /Classifications/Modellering/DeltaVar_Prep;
	
	unit<uint32> StandVar := union_unit(StandVar_rels, StandVar_Prep)
	{
		attribute<string> name                 := union_data(., StandVar_rels/name, StandVar_Prep/name);
		attribute<string> Subsector_name       := union_data(., StandVar_rels/Subsector_name, StandVar_Prep/Subsector_name);
		attribute<string> path                 := union_data(., StandVar_rels/path, StandVar_Prep/path);
		attribute<string> Sector_name          := union_data(., const('',StandVar_rels), StandVar_Prep/Sector_name);
		attribute<string> unit_name            := union_data(., StandVar_rels/unit_name, StandVar_Prep/unit_name);
		attribute<string> value_Type           := union_data(., StandVar_rels/value_Type, StandVar_Prep/value_Type);
		
		attribute<bool>   HasClaims            := union_data(., StandVar_rels/HasClaims, StandVar_Prep/HasClaims);
		attribute<bool>   HasAlloc             := union_data(., StandVar_rels/HasAlloc, StandVar_Prep/HasAlloc);
		attribute<bool>   IsVastgoed           := union_data(., StandVar_rels/IsVastgoed, StandVar_Prep/IsVastgoed);
		attribute<bool>   UseForLeegstandCorr  := union_data(., StandVar_rels/UseForLeegstandCorr, StandVar_Prep/UseForLeegstandCorr);
		
		attribute<bool>   IsLandbouw           := lowercase(Sector_name) == lowercase('Landbouw');
		attribute<bool>   is_quantity          := (lowercase(unit_name) != lowercase('Subsector') || lowercase(unit_name) != lowercase('Yr'));
		
		unit<uint8>  OP        := CaseClassifications/Vastgoed/OP;
		unit<uint32> Subsector := Classifications/Actor/Sector/xSubsector;
		unit<uint8>  Sector    := Classifications/Actor/Sector;
		
		unit<float32> Woning    := Units/Woning;
		unit<float32> Job       := Units/Job;
		unit<float32> m2        := Units/meter2;
		
		unit<uint32> Claims_sub := select_with_attr_by_cond(., HasClaims)
		{
			// attribute<bool>   IsLandbouw      := Sector_name == 'Landbouw';
			attribute<string> Subsector_name2 := lowercase(Subsector_name) == lowercase('Totaal') ? Sector_name : Subsector_name;
		}
		
		unit<uint32> Alloc_sub := select_with_attr_by_cond(.,HasAlloc);
		unit<uint32> LeegstandCorr_sub := select_with_attr_by_cond(.,UseForLeegstandCorr);
		unit<uint32> NietLeegstandCorr_sub := select_with_attr_by_cond(.,!UseForLeegstandCorr);
		unit<uint32> Vastgoed_sub := select_with_attr_by_cond(.,IsVastgoed);
	}
	
	unit<uint32> StandVarUint := select_with_attr_by_cond(., lowercase(StandVar/value_Type) == lowercase('uint8') || lowercase(StandVar/value_Type) == lowercase('uint32'))
	{
		unit<uint8>  OP        := CaseClassifications/Vastgoed/OP;
		unit<uint8>  Subsector := Classifications/Actor/Sector/xSubsector_uint8;
	}
	
	unit<uint32> StandVarfloat32 := select_with_attr_by_cond(., lowercase(StandVar/value_Type) == lowercase('float32'))
	{
		unit<float32> Woning    := Units/Woning;
		unit<float32> Job       := Units/Job;
		unit<float32> m2        := Units/meter2;
	}
	
	container Vastgoed
	{
		unit<uint8> OP := = 'VariantParameters/Ontwikkelpakketten/'+VariantParameters/VariantK/OntwikkelPakketVariant[Variant_rel];
	}
	
	unit<uint8> Scenario := select(lowercase(ScenarioK/name) == lowercase(Scenario_name))
	{
		attribute<string> name      := collect_by_cond(., ScenarioK/name);
		attribute<string> TableRef  := collect_by_cond(., ScenarioK/TableRef);
		attribute<bool> IsVoorExport:= collect_by_cond(., ScenarioK/IsVoorExport);
		
		container V := for_each_nedv(name, string(id(.))+'[..]', void, .);
		
		unit<uint8> Export := select_with_org_rel(IsVoorExport)
		{
			attribute<string> name := Scenario/name[org_rel];
		}
		
		unit<uint32> xVariantXSectorxSubsector := combine(., Actor/VariantXSectorxSubsector)
		{
			attribute<string> Scenario_name := Scenario/name[first_rel];
			attribute<string> VariantXSectorxSubsector_name := Actor/VariantXSectorxSubsector/name[second_rel];
			attribute<string> name := Scenario_name+'/'+VariantXSectorxSubsector_name;
			attribute<string> Label := replace(name, '/', '_');
			attribute<string> Sector_name := Actor/VariantXSectorxSubsector/Sector_name[second_rel];
			attribute<string> Subsector_name := Actor/VariantXSectorxSubsector/Subsector_name[second_rel];
			attribute<string> Combi_name := Actor/VariantXSectorxSubsector/Combi_name[second_rel];
			attribute<string> Combi_Label := replace(Combi_name, '/', '_');
			attribute<string> SrcRefGeschiktheid := Actor/VariantXSectorxSubsector/SrcRefGeschiktheid[second_rel];
		}
	}
	
	unit<uint32> AllocatieK := Scenario/xVariantXSectorxSubsector;
	
	unit<uint8> VariantK := select_with_attr_by_cond(VariantParameters/VariantK, UpperCase(VariantParameters/VariantK/name) == UpperCase(Variant_name));
	
	unit<uint32> ScenarioXAllocRegios := combine(Scenario, AllocRegiosK)
	{
		attribute<string> Scenario_name := Scenario/name[first_rel];
		attribute<string> AllocRegios_name := AllocRegiosK/name[second_rel];
		attribute<string> AllocRegioRef := AllocRegiosK/Ref[second_rel];
		attribute<string> Label := Scenario_name+'_'+AllocRegiosK/Label[second_rel];
		attribute<string> name := Scenario_name+'/'+AllocRegios_name;
		
		unit<uint32> xVariantXSectorxSubsector := combine(., Actor/VariantXSectorxSubsector)
		{
			attribute<string> ScenarioXAllocRegios_name := ../name[first_rel];
			attribute<string> ScenarioXAllocRegios_Label := ../Label[first_rel];
			attribute<string> VariantXSectorxSubsector_name := Actor/VariantXSectorxSubsector/name[second_rel];
			attribute<string> name := ScenarioXAllocRegios_name+'/'+VariantXSectorxSubsector_name;
			attribute<string> Scenario_name := ../Scenario_name[first_rel];
			attribute<string> AllocRegios_name := ../AllocRegios_name[first_rel];
			attribute<string> AllocRegioRef := ../AllocRegioRef[first_rel];
			attribute<string> Combi_name := Actor/VariantXSectorxSubsector/Combi_name[second_rel];
			attribute<string> Sector_name := Actor/VariantXSectorxSubsector/Sector_name[second_rel];
		}
	}
	
	container WindTurbineType
	{
		parameter<string>                              name              := = 'VariantParameters/VariantK/TurbineType[VariantParameters/VariantK/V/'+Variant_name+']';
		parameter<ModelParameters/Wind/MaxWerpAfstand> id                := = 'ModelParameters/Wind/MaxWerpAfstand/V/'+name;
		parameter<meter>                               Ashoogte          := ModelParameters/Wind/MaxWerpAfstand/Ashoogte[id];
		parameter<meter>                               RotorDiameter     := Ashoogte; //TO DO: RotorDiameter en Ashoogte zijn ongeveer gelijk, maar niet per se. Als de MaxWerpAfstandNom maar resultaat geeft, naar de lookup in de MaxWerpAfstand tabel.
		parameter<MW>                                  MW_per_turbine    := (ModelParameters/Wind/MaxWerpAfstand/Vermogen[id])[MW];
		parameter<meter>                               MaxWerpAfstandNom := ModelParameters/Wind/MaxWerpAfstand/MaxWerpAfstandNom[id];
	}
}