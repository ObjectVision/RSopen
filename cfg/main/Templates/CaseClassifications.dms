template CaseClassificationsT : using = "Classifications/modellering"
{
	//
	parameter<String> Scenario_name;
	parameter<String> Variant_name;
	//
	
	// BEGIN casus specific, overrule in vergelijk.dms; don't use in prepare.dms
	#include<Actor.dms>
	
	unit<UInt32> AllCases := combine(ScenarioK, VariantParameters/VariantK)
	{
		attribute<String> Scenario_name := ScenarioK/name[first_rel];
		attribute<String> Variant_name := VariantParameters/VariantK/name[second_rel];
		attribute<String> name := Scenario_name+'/'+Variant_name;
		attribute<String> Label := Scenario_name+'_'+Variant_name, DialogType = "LabelText";
	}
	
	unit<UInt32> ZichtjaarxTXLClaims := combine(Time/Zichtjaar, TigrisXL/Claims)
	{
		attribute<String> Zichtjaar_name := Time/Zichtjaar/name[first_rel];
		attribute<String> TXLClaims_name := TigrisXL/Claims/name[second_rel];
		attribute<String> TXLClaims_ref  := TigrisXL/Claims/TigrisXL_Table_ref[second_rel];
		attribute<String> Label          := Zichtjaar_name+'_'+TXLClaims_name, DialogType = "LabelText";
		attribute<String> name           := Zichtjaar_name+'/'+TXLClaims_name;
	}
	
	unit<UInt32> ZichtjaarxTXLClaimsxCase := combine(ZichtjaarxTXLClaims, AllCases)
	{
		attribute<String> Zichtjaar_name   := ZichtjaarxTXLClaims/Zichtjaar_name[first_rel];
		attribute<String> TXLClaims_name   := ZichtjaarxTXLClaims/TXLClaims_name[first_rel];
		attribute<String> Attr_ref         := TigrisXL/Claims/Attr_ref[ZichtjaarxTXLClaims/second_rel[first_rel]];
		attribute<String> Sector_name      := lowercase(TXLClaims_name) == lowercase('banen') ? 'Werken' : 'Wonen';
		attribute<String> TargetValUnitRef := TigrisXL/Claims/TargetValUnitRef[ZichtjaarxTXLClaims/second_rel[first_rel]];
		attribute<String> TXLClaims_ref    := ZichtjaarxTXLClaims/TXLClaims_ref[first_rel];
		attribute<String> Scenario_name    := AllCases/Scenario_name[second_rel];
		attribute<String> Variant_name     := AllCases/Variant_name[second_rel];
		attribute<String> name             := Zichtjaar_name+'/'+TXLClaims_name+'/'+Scenario_name+'/'+Variant_name;
		attribute<String> Label            := Zichtjaar_name+'_'+TXLClaims_name+'_'+Scenario_name+'_'+Variant_name, DialogType = "LabelText";
	}
	
	unit<UInt32> StandVar_rels := range(uint32, 0, 2)
	{
		attribute<String> name                 : ['SubSector_rel','OP_rel'];
		attribute<String> Subsector_name       : ['',''];
		attribute<String> path                 : ['SubSector_rel','OP_rel'];
		attribute<String> unit_name            : ['Subsector','OP'];
		attribute<String> value_Type           : ['uint32','uint8'];
		attribute<Bool>   HasClaims            : [FALSE, FALSE];
		attribute<Bool>   HasAlloc             : [FALSE, FALSE];
		attribute<Bool>   IsVastgoed           : [FALSE, FALSE];
		attribute<Bool>   UseForLeegstandCorr  : [FALSE, FALSE];
	}
	unit<UInt32> StandVar_Prep  := Classifications/Modellering/StandVar_Prep;
	unit<UInt32> DeltaVar_Prep  := /Classifications/Modellering/DeltaVar_Prep;
	
	unit<UInt32> StandVar := union_unit(StandVar_rels, StandVar_Prep)
	{
		attribute<String> name                 := union_data(., StandVar_rels/name, StandVar_Prep/name);
		attribute<String> Subsector_name       := union_data(., StandVar_rels/Subsector_name, StandVar_Prep/Subsector_name);
		attribute<String> path                 := union_data(., StandVar_rels/path, StandVar_Prep/path);
		attribute<String> Sector_name          := union_data(., const('',StandVar_rels), StandVar_Prep/Sector_name);
		attribute<String> unit_name            := union_data(., StandVar_rels/unit_name, StandVar_Prep/unit_name);
		attribute<String> value_Type           := union_data(., StandVar_rels/value_Type, StandVar_Prep/value_Type);
		
		attribute<Bool>   HasClaims            := union_data(., StandVar_rels/HasClaims, StandVar_Prep/HasClaims);
		attribute<Bool>   HasAlloc             := union_data(., StandVar_rels/HasAlloc, StandVar_Prep/HasAlloc);
		attribute<Bool>   IsVastgoed           := union_data(., StandVar_rels/IsVastgoed, StandVar_Prep/IsVastgoed);
		attribute<Bool>   UseForLeegstandCorr  := union_data(., StandVar_rels/UseForLeegstandCorr, StandVar_Prep/UseForLeegstandCorr);
		
		attribute<Bool>   IsLandbouw           := lowercase(Sector_name) == lowercase('Landbouw');
		attribute<Bool>   is_quantity          := (lowercase(unit_name) != lowercase('Subsector') || lowercase(unit_name) != lowercase('Yr'));
		
		unit<UInt8>  OP        := CaseClassifications/Vastgoed/OP;
		unit<UInt32> Subsector := Classifications/Actor/Sector/xSubsector;
		unit<UInt8>  Sector    := Classifications/Actor/Sector;
		
		unit<Float32> Woning    := Units/Woning;
		unit<Float32> Job       := Units/Job;
		unit<Float32> m2        := Units/meter2;
		
		unit<UInt32> Claims_sub := select_with_attr_by_cond(., HasClaims)
		{
			// attribute<Bool>   IsLandbouw      := Sector_name == 'Landbouw';
			attribute<String> Subsector_name2 := lowercase(Subsector_name) == lowercase('Totaal') ? Sector_name : Subsector_name;
		}
		
		unit<UInt32> Alloc_sub := select_with_attr_by_cond(.,HasAlloc);
		unit<UInt32> LeegstandCorr_sub := select_with_attr_by_cond(.,UseForLeegstandCorr);
		unit<UInt32> NietLeegstandCorr_sub := select_with_attr_by_cond(.,!UseForLeegstandCorr);
		unit<UInt32> Vastgoed_sub := select_with_attr_by_cond(.,IsVastgoed);
	}
	
	unit<UInt32> StandVarUint := select_with_attr_by_cond(., lowercase(StandVar/value_Type) == lowercase('uint8') || lowercase(StandVar/value_Type) == lowercase('uint32'))
	{
		unit<UInt8>  OP        := CaseClassifications/Vastgoed/OP;
		unit<UInt8>  Subsector := Classifications/Actor/Sector/xSubsector_uint8;
	}
	
	unit<UInt32> StandVarfloat32 := select_with_attr_by_cond(., lowercase(StandVar/value_Type) == lowercase('float32'))
	{
		unit<Float32> Woning    := Units/Woning;
		unit<Float32> Job       := Units/Job;
		unit<Float32> m2        := Units/meter2;
	}
	
	container Vastgoed
	{
		unit<UInt8> OP := = 'VariantParameters/Ontwikkelpakketten/DezeBuurtSchaal/'+VariantParameters/VariantK/OntwikkelPakketVariant[Variant_rel];
	}
	
	unit<UInt8> Scenario := select(lowercase(ScenarioK/name) == lowercase(Scenario_name))
	{
		attribute<String> name      := collect_by_cond(., ScenarioK/name);
		attribute<String> TableRef  := collect_by_cond(., ScenarioK/TableRef);
		attribute<Bool> IsVoorExport:= collect_by_cond(., ScenarioK/IsVoorExport);
		
		container V := for_each_nedv(name, string(id(.))+'[..]', void, .);
		
		unit<UInt8> Export := select_with_org_rel(IsVoorExport)
		{
			attribute<String> name := Scenario/name[org_rel];
		}
		
		unit<UInt32> xVariantXSectorxSubsector := combine(., Actor/VariantXSectorxSubsector)
		{
			attribute<String> Scenario_name := Scenario/name[first_rel];
			attribute<String> VariantXSectorxSubsector_name := Actor/VariantXSectorxSubsector/name[second_rel];
			attribute<String> name := Scenario_name+'/'+VariantXSectorxSubsector_name;
			attribute<String> Label := replace(name, '/', '_');
			attribute<String> Sector_name := Actor/VariantXSectorxSubsector/Sector_name[second_rel];
			attribute<String> Subsector_name := Actor/VariantXSectorxSubsector/Subsector_name[second_rel];
			attribute<String> Combi_name := Actor/VariantXSectorxSubsector/Combi_name[second_rel];
			attribute<String> Combi_Label := replace(Combi_name, '/', '_');
			attribute<String> SrcRefGeschiktheid := Actor/VariantXSectorxSubsector/SrcRefGeschiktheid[second_rel];
		}
	}
	
	unit<UInt32> AllocatieK := Scenario/xVariantXSectorxSubsector;
	
	unit<UInt8> VariantK := select_with_attr_by_cond(VariantParameters/VariantK, UpperCase(VariantParameters/VariantK/name) == UpperCase(Variant_name));
	
	unit<UInt32> ScenarioXAllocRegios := combine(Scenario, AllocRegiosK)
	{
		attribute<String> Scenario_name := Scenario/name[first_rel];
		attribute<String> AllocRegios_name := AllocRegiosK/name[second_rel];
		attribute<String> AllocRegioRef := AllocRegiosK/Ref[second_rel];
		attribute<String> Label := Scenario_name+'_'+AllocRegiosK/Label[second_rel];
		attribute<String> name := Scenario_name+'/'+AllocRegios_name;
		
		unit<UInt32> xVariantXSectorxSubsector := combine(., Actor/VariantXSectorxSubsector)
		{
			attribute<String> ScenarioXAllocRegios_name := ../name[first_rel];
			attribute<String> ScenarioXAllocRegios_Label := ../Label[first_rel];
			attribute<String> VariantXSectorxSubsector_name := Actor/VariantXSectorxSubsector/name[second_rel];
			attribute<String> name := ScenarioXAllocRegios_name+'/'+VariantXSectorxSubsector_name;
			attribute<String> Scenario_name := ../Scenario_name[first_rel];
			attribute<String> AllocRegios_name := ../AllocRegios_name[first_rel];
			attribute<String> AllocRegioRef := ../AllocRegioRef[first_rel];
			attribute<String> Combi_name := Actor/VariantXSectorxSubsector/Combi_name[second_rel];
			attribute<String> Sector_name := Actor/VariantXSectorxSubsector/Sector_name[second_rel];
		}
	}
	
	container WindTurbineType
	{
		parameter<String>                              name              := = 'VariantParameters/VariantK/TurbineType[VariantParameters/VariantK/V/'+Variant_name+']';
		parameter<ModelParameters/Wind/MaxWerpAfstand> id                := = 'ModelParameters/Wind/MaxWerpAfstand/V/'+name;
		parameter<meter>                               Ashoogte          := ModelParameters/Wind/MaxWerpAfstand/Ashoogte[id];
		parameter<meter>                               RotorDiameter     := Ashoogte; //TO DO: RotorDiameter en Ashoogte zijn ongeveer gelijk, maar niet per se. Als de MaxWerpAfstandNom maar resultaat geeft, naar de lookup in de MaxWerpAfstand tabel.
		parameter<MW>                                  MW_per_turbine    := (ModelParameters/Wind/MaxWerpAfstand/Vermogen[id])[MW];
		parameter<meter>                               MaxWerpAfstandNom := ModelParameters/Wind/MaxWerpAfstand/MaxWerpAfstandNom[id];
	}
}