////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Dit is RSOpen, de open source versie van het model RuimteScanner. Het scipt wordt uitgegeven onder GNU-GPL licentie.
//
// RSOpen is ontwikkeld door PBL Planbureau voor de Leefomgeving, i.s.m Object Vision B.V. en VU Vrije Universiteit Amsterdam.
// Opdrachtgever/ontwikkelaar PBL: Bart Rijken
// Contactpersoon/ontwikkelaar Object Vision B.V.: Jip Claassens (jclaassens@objectvision.nl)
// Contacpersoon PBL: Bas van Bemmel (Bas.vanBemmel@pbl.nl)
//
// Deze file specificeert de VariantParameters: Parameters die voor elke Variant verschillen, maar, gegeven een Variant, hetzelfde zijn voor de scenario's.
// De configuratie bevat vijf (beleids)Varianten: Business As Usual (BAU), Snelle Wereld (SW), GroenLand (GL), MondiaalOndernemend (MO), RegionaalGeworteld (RG).
// De BAU Variant is uitgewerkt voor de 'Planmonitor NOVI 2023' (Kuiper, Rijken, Van Bemmel, 2023) : https://www.pbl.nl/publicaties/planmonitor-novi-2023
// De overige Varianten zijn afkomstig uit de 'Ruimtelijke Verkenning 2023' (PBL, 2023) : https://www.pbl.nl/publicaties/planmonitor-novi-2023
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

container VariantParameters: using = "Classifications"
{
	#include<VariantK.dms>
	#include<EvidentBenut.dms>
	#include<Tredes.dms>
	#include<Ontwikkelpakketten.dms>
	#include<FractiesGroenInWerken.dms>
	#include<FractiesGroenInVerblijfsrecreatie.dms>
	
	parameter<String> Recreatie_AllocRegio_name := = 'VariantK/Verblijfsrecreatie_AllocRegio_name[VariantK/V/'+Variant_name+']';
	
	unit<UInt8> Sector     := Classifications/Actor/Sector;
	unit<UInt8> AllocRegio := Classifications/Modellering/AllocRegiosK;
	
	unit<UInt8> SectorAllocRegio := range(uint8, 0b, 5b) //1b
	, Descr = "Volgorde waarin de sectoren gealloceerd worden, incluisef het schaalniveau waarop dit (achtereenvolgens) gebeurt (de AllocRegio's)."
	{
		unit<Uint32> Elements := Range(uint32, 0, nrAttr * #.) 
		, Descr = "Gelijke sectoren moeten direct na elkaar komen. van klein naar grote alloc regios. Teneinde verdringing zo lokaal mogelijk op te lossen. Anders kan wel, maar geeft wellicht onwenselijke resultaten."
		{
			attribute<String> Text: [
			// name                , AllocRegio            , UseInLaterSeq , AantalIters        , AantalItersInLaterSeq
			  // 'Wonen'              , 'NVM'                 ,  'TRUE'       ,'Default_NrOfIters' ,'Default_NrOfIters'
			  'Wonen'              , 'COROP'               , 'FALSE'       ,'Default_NrOfIters' ,'Default_NrOfIters'
			 ,'Wonen'              , 'Provincie'           , 'FALSE'       ,'Default_NrOfIters' ,'Default_NrOfIters'
			 // ,'Werken'             , 'NVM'                 ,  'TRUE'       ,'Default_NrOfIters' ,'Default_NrOfIters'
			 ,'Werken'             , 'COROP'               , 'FALSE'       ,'Default_NrOfIters' ,'Default_NrOfIters'
			 ,'Werken'             , 'Provincie'           , 'FALSE'       ,'Default_NrOfIters' ,'Default_NrOfIters'
			 ,'Verblijfsrecreatie' , 'Rec_AllocRegio_name' ,  'TRUE'       ,'Default_NrOfIters' ,'Default_NrOfIters'
			 // ,'Zon'                , 'Provincie'           ,  'TRUE'       ,'Default_NrOfIters' ,'Default_NrOfIters'
			 // ,'Wind'               , 'Provincie'           ,  'TRUE'       ,'NrOfIters_Wind'    ,'NrOfIters_Wind'
			 //,'Wind'               , 'NL'                  , 'FALSE'       ,'Default_NrOfIters' ,'Default_NrOfIters'
			 //,'Landbouw'           , 'Provincie'           , 'FALSE'       ,'Default_NrOfIters' ,'Default_NrOfIters'
			];
		}
		
		attribute<String>     Default_Sectorname    := Elements/Text[value(uint32(id(.))* nrAttr + 0, Elements)];
		attribute<Sector>     Default_Sector        := ='union_data(.,'+asList('Sector/V/'+Default_Sectorname, ',')+')', Descr = "relatie naar Sector";
		attribute<String>     Default_Regioname     := replace(Elements/Text[value(uint32(id(.))* nrAttr + 1, Elements)], 'Rec_AllocRegio_name', Recreatie_AllocRegio_name);
		attribute<AllocRegio> Default_Regio         := ='union_data(.,'+asList('AllocRegio/V/'+Default_Regioname, ',')+')', Descr = "relatie naar AllocRegio";
		
		
		// Kan een sector verdrongen worden door daarop volgende sectoren? In dat geval moet deze sector in een volgende sequence opnieuw worden doorlopen. In dat geval moet deze sector TRUE krijgen.
		// Verdringing wordt vervolgens zo lokaal mogelijk opgelost, en dus krijgt de kleinste regio per sector een TRUE.
		attribute<Bool>       UseInLaterSequences   := Elements/Text[value(uint32(id(.))* nrAttr + 2, Elements)][bool]; 
		attribute<UInt8>      AantalIters           := uint8(replace(Elements/Text[value(uint32(id(.))* nrAttr + 3, Elements)], 'Default_NrOfIters', string(ModelParameters/Default_NrOfIters), 'NrOfIters_Wind', string(ModelParameters/Wind/NrOfIters_Wind))), Descr = "Hier wordt het aantal iteraties uit de ModelParameters opgehaald en in deze lijst toegevoegd.";
		attribute<UInt8>      AantalItersInLaterSeq := uint8(replace(Elements/Text[value(uint32(id(.))* nrAttr + 4, Elements)], 'Default_NrOfIters', string(ModelParameters/Default_NrOfIters), 'NrOfIters_Wind', string(ModelParameters/Wind/NrOfIters_Wind))), Descr = "Er kan eventueel voor worden gekozen in latere sequenties minder iteraties te gebruiken. Dat kan hier insteld worden.";
		attribute<String>     SortOrder             := string(rlookup(Default_Sectorname, Default_Sectorname)), Descr = "foolproof oplossing om een sortorder af te dwingen, die gebruikt wordt bij de sortering van Uq_Sectors";

		attribute<AllocRegio> AllocRegio_rel        := Default_Regio;
		attribute<Sector>     Sector_rel            := Default_Sector;
		
		attribute<String>     name                  := AllocRegio_name +'_'+ Sector_name;
		attribute<String>     SectorAllocRegio_name := Sector_name +'_'+ AllocRegio_name;
		attribute<String>     Sector_name           := Sector/name[Sector_rel];
		attribute<String>     AllocRegio_name       := AllocRegio/name[AllocRegio_rel];
		attribute<String>     AllocRegio_path       := AllocRegio/path[AllocRegio_rel];
		
		unit<UInt8> WonenAllocRegio := select_with_org_rel(Sector_rel == Sector/V/Wonen);
		
		unit<UInt8> Uq_AllocRegios := unique(AllocRegio_name)
		, Descr = "Unieke lijst van AllocRegio's die in deze variant gebruikt worden. Nodig om bijvoorbeeld voor alle gebruikte allocregio's iets uit te rekenen."
		{
			attribute<String> AllocRegio_name := values;
			attribute<String> AllocRegio_path := rjoin(lowercase(AllocRegio_name), lowercase(../AllocRegio_name), ../AllocRegio_path);
		}
		unit<UInt8> Uq_Sectors := unique(SortOrder + Default_Sectorname)
		, Descr = "SortOrder wordt hier voorgezet om ervoor te zorgen dat dit niet alfabetisch wordt gesorteerd.
					Dit wordt gebruikt om in if-statements te kijken of bepaalde sectoren wel of niet gealloceerd worden."
		{
			attribute<String> Sectorname                  := substr(values, 1, 99);
			attribute<Bool>   IsWonen                     := lowercase(Sectorname) == lowercase('Wonen');
			attribute<Bool>   IsWerken                    := lowercase(Sectorname) == lowercase('Werken');
			attribute<Bool>   IsVerblijfsrecreatie        := lowercase(Sectorname) == lowercase('Verblijfsrecreatie');
			attribute<Bool>   IsZon                       := lowercase(Sectorname) == lowercase('Zon');
			attribute<Bool>   IsWind                      := lowercase(Sectorname) == lowercase('Wind');
			attribute<Bool>   IsLandbouw                  := lowercase(Sectorname) == lowercase('Landbouw');
			parameter<Bool>   HasWonenSector              := any(IsWonen);
			parameter<Bool>   HasWerkenSector             := any(IsWerken);
			parameter<Bool>   HasVerblijfsrecreatieSector := any(IsVerblijfsrecreatie);
			parameter<Bool>   HasZonSector                := any(IsZon);
			parameter<Bool>   HasWindSector               := any(IsWind);
			parameter<Bool>   HasLandbouwSector           := any(IsLandbouw);
			
			unit<UInt8> wo_Landbouw := select_with_attr_by_cond(., NOT(IsLandbouw));
		}
		
		parameter<UInt32> nrAttr := 5;
	}
}