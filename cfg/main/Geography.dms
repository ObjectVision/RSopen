////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Dit is RSOpen, de open source versie van het model RuimteScanner. Het scipt wordt uitgegeven onder GNU-GPL licentie.
//
// RSOpen is ontwikkeld door PBL Planbureau voor de Leefomgeving, i.s.m Object Vision B.V. en VU Vrije Universiteit Amsterdam.
// Opdrachtgever/ontwikkelaar PBL: Bart Rijken
// Contactpersoon/ontwikkelaar Object Vision B.V.: Jip Claassens (jclaassens@objectvision.nl)
// Contacpersoon PBL: Bas van Bemmel (Bas.vanBemmel@pbl.nl)
//
// Deze file specificeert de verschillende grid domains die kunnen worden gebruikt in het model, RegioIndelingen, en afstandsmatrices.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

container Geography: using = "Units"
, Descr = "Definities van de verschillende grid domains die kunnen worden gebruikt in het model, RegioIndelingen, en afstandsmatrices."
{
	unit<DPoint> rdc_meter_base   : DialogData = "ngr_layer", SpatialReference = "EPSG:28992", Descr = "Geografisch domain in RD-coordinaten, gedefinieerd in meters.";
	unit<DPoint> rdc_meter_NL     := range(rdc_meter_base, point_xy(min_max/x_min_Nederland, min_max/y_min_Nederland,rdc_meter_base), point_xy(min_max/x_max_Nederland, min_max/y_max_Nederland,rdc_meter_base)), Descr = "Geografisch domain in RD-coordinaten, afgebakend tot Nederland.";
	unit<IPoint> rdc_mm_base      := gridset(rdc_meter_NL,  point_yx(0.001, 0.001), point_yx(0.0, 0.0), ipoint), Descr = "Geografisch domain in RD-coordinaten, afgebakend tot Nederland, in millimeters (en dus integers)";
	unit<WPoint> rdc_km_base      := gridset(rdc_meter_NL,  point_yx(1000, 1000), point_yx(0.0, 0.0), wpoint), Descr = "Geografisch domain in RD-coordinaten, afgebakend tot Nederland, in kilometers (en dus integers)";
	unit<DPoint> rdc_meter        := ='StudyAreas/rdc_'+ModelParameters/StudyArea, Descr = "Geografisch domain in RD-coordinaten, gedefinieerd in meters, afgebakend op het studiegebied.";
	unit<IPoint> rdc_mm           := gridset(rdc_meter,  point_yx(0.001, 0.001), point_yx(0.0, 0.0), ipoint), Descr = "Geografisch domain in RD-coordinaten, afgebakend op het studiegebied, in millimeters (en dus integers)";
	

	unit<FPoint> LambertEA_base   : SpatialReference = "EPSG:3035", DialogData = "ngr_layer_lea", Descr = "Geografisch domain in Lambert EA coordinaten, gedefinieerd in meters.";
	unit<FPoint> LambertEA        := range(LambertEA_base, point_yx(2500000f, 1300000f), point_yx(4900000f, 4300000f)), Descr = "Geografisch domain in Lambert EA coordinaten, afgebakend op Europa.";
	unit<DPoint> wgs84_base       : SpatialReference = "EPSG:4326", Descr = "Geografisch domain in WGS84 coordinaten, gedefinieerd in graden.";
	
	container StudyAreas
	{
		unit<DPoint> rdc_Nederland             := rdc_meter_NL
		, Descr = "Geografisch domain in RD-coordinaten, afgebakend tot Nederland."
		{
			parameter<rdc_meter_base> geometry_base                  (poly) := SourceData/RegioIndelingen/NL/geometry_base[SourceData/RegioIndelingen/NL/V/Nederland];
			attribute<rdc_meter>      geometry          (poly, UnityDomain) := union_data(UnityDomain, geometry_base[rdc_meter]);
			attribute<Bool>           IsStudyArea_AdminDomain (AdminDomain) := IsDefined(poly2grid(geometry, AdminDomain));
			attribute<Bool>           IsStudyArea_AllocDomain (AllocDomain) := IsDefined(poly2grid(geometry, AllocDomain));
			attribute<String>         name                    (UnityDomain) := const('Nederland',UnityDomain);
			container BoundingBoxPlus := Make_BoundingBoxPlus_T(geometry, 5000[meter_f64]);
		}
		
		unit<DPoint> rdc_Friesland             := range(rdc_meter_base
															, Lower_Bound(SourceData/RegioIndelingen/Provincie/Per_Prov/Friesland/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Friesland]])[rdc_km_base][rdc_meter_NL]
															, (Upper_Bound(SourceData/RegioIndelingen/Provincie/Per_Prov/Friesland/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Friesland]])[rdc_km_base] + point_xy(1w,1w,rdc_km_base))[rdc_meter_NL]
													)
		, Descr = "Geografisch domain in RD-coordinaten, afgebakend tot Friesland."
		{
			parameter<rdc_meter_base> geometry_base                  (poly) := SourceData/RegioIndelingen/Provincie/Per_Prov/Friesland/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Friesland]];
			attribute<rdc_meter>      geometry          (poly, UnityDomain) := union_data(UnityDomain, geometry_base[rdc_meter]);
			attribute<Bool>           IsStudyArea_AdminDomain (AdminDomain) := IsDefined(poly2grid(geometry, AdminDomain));
			attribute<Bool>           IsStudyArea_AllocDomain (AllocDomain) := IsDefined(poly2grid(geometry, AllocDomain));
			
			parameter<Ha>             Areaal                                := area(geometry[0], meter2)[ha];
			attribute<String>         name                    (UnityDomain) := const('Friesland',UnityDomain);
			container BoundingBoxPlus := Make_BoundingBoxPlus_T(geometry, 5000[meter_f64]);
		}
		
		unit<DPoint> rdc_Noord_Holland         := range(rdc_meter_base, Upper_Bound(SourceData/RegioIndelingen/Provincie/Per_Prov/Noord_Holland/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Noord_Holland]]), Lower_Bound(SourceData/RegioIndelingen/Provincie/Per_Prov/Noord_Holland/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Noord_Holland]]))  
		, Descr = "Geografisch domain in RD-coordinaten, afgebakend tot Noord-Holland."
		{
			parameter<rdc_meter_base> geometry_base                  (poly) := SourceData/RegioIndelingen/Provincie/Per_Prov/Noord_Holland/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Noord_Holland]];
			attribute<rdc_meter>      geometry          (poly, UnityDomain) := union_data(UnityDomain, geometry_base[rdc_meter]);
			attribute<Bool>           IsStudyArea_AdminDomain (AdminDomain) := IsDefined(poly2grid(geometry, AdminDomain));
			attribute<Bool>           IsStudyArea_AllocDomain (AllocDomain) := IsDefined(poly2grid(geometry, AllocDomain));
			attribute<String>         name                    (UnityDomain) := const('Noord_Holland',UnityDomain);
			container BoundingBoxPlus := Make_BoundingBoxPlus_T(geometry, 5000[meter_f64]);
		}
		unit<DPoint> rdc_Utrecht               := range(rdc_meter_base, Upper_Bound(SourceData/RegioIndelingen/Provincie/Per_Prov/Utrecht/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Utrecht]]), Lower_Bound(SourceData/RegioIndelingen/Provincie/Per_Prov/Utrecht/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Utrecht]]))  
		, Descr = "Geografisch domain in RD-coordinaten, afgebakend tot provincie Utrecht."
		{
			parameter<rdc_meter_base> geometry_base                  (poly) := SourceData/RegioIndelingen/Provincie/Per_Prov/Utrecht/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Utrecht]];
			attribute<rdc_meter>      geometry          (poly, UnityDomain) := union_data(UnityDomain, geometry_base[rdc_meter]);
			attribute<Bool>           IsStudyArea_AdminDomain (AdminDomain) := IsDefined(poly2grid(geometry, AdminDomain));
			attribute<Bool>           IsStudyArea_AllocDomain (AllocDomain) := IsDefined(poly2grid(geometry, AllocDomain));
			attribute<String>         name                    (UnityDomain) := const('Utrecht',UnityDomain);
			container BoundingBoxPlus := Make_BoundingBoxPlus_T(geometry, 5000[meter_f64]);
		}
		
		unit<UInt32> UnityDomain : NrOfRows = 1;
		
		Template Make_BoundingBoxPlus_T
		: Descr = "Maakt een bounding box polygon rond de geometry met PlusSize buffer."
		{
			attribute<rdc_meter> geometry (poly, UnityDomain);
			parameter<meter_f64> PlusSize;
			///
			attribute<rdc_meter> polygon (poly, UnityDomain) := points2sequence(BoundingBoxPlus/point_set/point, BoundingBoxPlus/point_set/Sequence_rel, BoundingBoxPlus/point_set/ordinal);
			
			unit<UInt32> BoundingBoxPlus := UnityDomain
			{
				attribute<rdc_meter> LB := Lower_Bound(geometry);
				attribute<rdc_meter> UB := Upper_Bound(geometry);
				
				attribute<rdc_meter> top_left     := point_xy(Get_X(LB)[meter_f64] - PlusSize, Get_Y(UB)[meter_f64] + PlusSize, rdc_meter); 
				attribute<rdc_meter> top_right    := point_xy(Get_X(UB)[meter_f64] + PlusSize, Get_Y(UB)[meter_f64] + PlusSize, rdc_meter);
				attribute<rdc_meter> bottom_left  := point_xy(Get_X(LB)[meter_f64] - PlusSize, Get_Y(LB)[meter_f64] - PlusSize, rdc_meter);
				attribute<rdc_meter> bottom_right := point_xy(Get_X(UB)[meter_f64] + PlusSize, Get_Y(LB)[meter_f64] - PlusSize, rdc_meter);
				
				unit<UInt32> point_set : NrOfRows = 5
				{
					attribute<rdc_meter>  point        := union_data(., top_left, top_right, bottom_right, bottom_left, top_left);
					attribute<..>         Sequence_rel := const(0, .);
					attribute<.>          ordinal      := id(.);
				}
			}
		}
	}
	
	unit<UInt32> Gridsizes : NrOfRows = 7
	, Descr = "Verschillende gridsizes die gebruikt kunnen worden in het model, in meters."
	{
		attribute<String>  size_str : ['2.5', '5', '10', '25', '100', '250', '500'];
		attribute<meter>   size     := size_str[meter];
		
		attribute<String>  name0    := 'size_'+string(size)+'m';
		attribute<String>  name     := replace(name0, '2.5', '2_5');
	}
	
	unit<IPoint> rdc_2_5m  := perGridsize/size_2_5m/domain;
	unit<IPoint> rdc_5m    := perGridsize/size_5m/domain;
	unit<IPoint> rdc_10m   := perGridsize/size_10m/domain;
	unit<IPoint> rdc_25m   := perGridsize/size_25m/domain;
	unit<IPoint> rdc_100m  := perGridsize/size_100m/domain;
	unit<IPoint> rdc_250m  := perGridsize/size_250m/domain;
	unit<IPoint> rdc_500m  := perGridsize/size_500m/domain;
	
	container min_max 
	: Descr = "Bevat de minimale en maximale x en y coordinaten van de verschillende studiegebieden."
	{
		parameter<Float64> x_min_Nederland     := 0d;
		parameter<Float64> x_max_Nederland     := 280000d;
		parameter<Float64> y_min_Nederland     := 300000d;
		parameter<Float64> y_max_Nederland     := 625000d;
		
		parameter<Float64> x_min_Noord_Holland := PointCol(LowerBound(StudyAreas/rdc_Noord_Holland));
		parameter<Float64> x_max_Noord_Holland := PointCol(UpperBound(StudyAreas/rdc_Noord_Holland));
		parameter<Float64> y_min_Noord_Holland := PointRow(LowerBound(StudyAreas/rdc_Noord_Holland));
		parameter<Float64> y_max_Noord_Holland := PointRow(UpperBound(StudyAreas/rdc_Noord_Holland));
		
		parameter<Float64> x_min_Friesland     := PointCol(Lower_Bound(SourceData/RegioIndelingen/Provincie/Per_Prov/Friesland/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Friesland]]));
		parameter<Float64> x_max_Friesland     := PointCol(Upper_Bound(SourceData/RegioIndelingen/Provincie/Per_Prov/Friesland/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Friesland]]));
		parameter<Float64> y_min_Friesland     := PointRow(Lower_Bound(SourceData/RegioIndelingen/Provincie/Per_Prov/Friesland/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Friesland]]));
		parameter<Float64> y_max_Friesland     := PointRow(Upper_Bound(SourceData/RegioIndelingen/Provincie/Per_Prov/Friesland/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Friesland]]));
		
		parameter<Float64> x_min_Utrecht     := PointCol(Lower_Bound(SourceData/RegioIndelingen/Provincie/Per_Prov/Utrecht/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Utrecht]]));
		parameter<Float64> x_max_Utrecht     := PointCol(Upper_Bound(SourceData/RegioIndelingen/Provincie/Per_Prov/Utrecht/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Utrecht]]));
		parameter<Float64> y_min_Utrecht     := PointRow(Lower_Bound(SourceData/RegioIndelingen/Provincie/Per_Prov/Utrecht/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Utrecht]]));
		parameter<Float64> y_max_Utrecht     := PointRow(Upper_Bound(SourceData/RegioIndelingen/Provincie/Per_Prov/Utrecht/geometry_base[0[SourceData/RegioIndelingen/Provincie/Per_Prov/Utrecht]]));
	}
	
	parameter<Float64> x_min := ='min_max/x_min_'+/ModelParameters/StudyArea;
	parameter<Float64> x_max := ='min_max/x_max_'+/ModelParameters/StudyArea;
	parameter<Float64> y_min := ='min_max/y_min_'+/ModelParameters/StudyArea;
	parameter<Float64> y_max := ='min_max/y_max_'+/ModelParameters/StudyArea;
	
	container perGridsize := for_each_ne(Gridsizes/name, 'Create_GridDomain_T('+string(Gridsizes/size)+'[float64])'), Descr = "Bevat de verschillende grid domains die gebruikt kunnen worden in het model, op basis van de verschillende gridsizes.";
	
	unit<UInt8> Matrix : NrOfRows = 26
	, Descr = "Bevat de verschillende afstandsmatrices die gebruikt kunnen worden in het model."
	{
		attribute<meter>   size : [ 0, 17, 25, 50, 100, 150, 200, 300, 400, 500, 600, 625, 700, 1000, 1250, 1500, 2000, 2250, 2500, 3250, 5000, 5250, 10000, 10250, 20000, 20250 ];
		attribute<String>  name := 'pot'+string(size)+'m';
	}
	
	container Distmatrices_25m  := for_each_nex(Matrix/name, 'Distmatrices/Impl_25m/'+Matrix/name+'/PotRange', spoint), Descr = "Bevat de verschillende afstandsmatrices die gebruikt kunnen worden in het model, op basis van een grid van 25m.";
	container Distmatrices_100m := for_each_nex(Matrix/name, 'Distmatrices/Impl_100m/'+Matrix/name+'/PotRange', spoint), Descr = "Bevat de verschillende afstandsmatrices die gebruikt kunnen worden in het model, op basis van een grid van 100m.";
	
	unit<UInt32> TileDomain := ='union_unit('+asItemList('CreateTiles/LoopPolygons/'+string(CreateTiles/TileSet/name)+'/shape')+')'
	, Descr = "Domain met alle tegels die gebruikt worden in het model, om berekeningen in te delen in behapbare stukken."
	{
		attribute<rdc_meter>    geometry (poly) := ='union_data(.,'+asItemList('CreateTiles/LoopPolygons/'+string(CreateTiles/TileSet/name)+'/shape/geometry')+')';
		attribute<String> name            := ='union_data(.,'+asItemList('CreateTiles/LoopPolygons/'+string(CreateTiles/TileSet/name)+'/shape/name')+')';
	}
	
	#include<CreateTiles.dms>
	#include<Distmatrices.dms>
	#include<Create_GridDomain_T.dms>
	#include<ngr_layer.dms> // reference WMS layer
	
	parameter<String> AllocDomain_ref       := 'rdc_'+AllocDomain_ref_short, Descr = "Keuze van het ruimtelijke resolutie waarop de allocatie plaatsvindt (keuze-eenheid). Dit kan 100m of 25m zijn.";
	parameter<String> AdminDomain_ref       := 'rdc_'+AdminDomain_ref_short, Descr = "Keuze van het ruimtelijke resolutie waarop de administratieve resultaten worden geadminstreerd (keuze-eenheid). Dit kan 100m of 25m zijn.";
	parameter<String> AllocDomain_ref_short := ModelParameters/Advanced/AllocDomain_ref;
	parameter<String> AdminDomain_ref_short := ModelParameters/Advanced/AdminDomain_ref;

	unit<IPoint> AdminDomain := =ModelParameters/Advanced/AdminDomain_ref == '100m' ? 'Geography/rdc_100m' : 'Geography/rdc_25m' 
	, Descr = "Ruimtelijke resolutie waarop de administratieve resultaten worden geadminstreerd (keuze-eenheid). Dit kan 100m of 25m zijn."
	{
		parameter<String> name              := 'AdminDomain';
		attribute<Bool>   IsCompactedDomain := AllocDomain/IsCompactedDomain[AllocDomain_rel], Descr = "Of het compacted domain is wordt bepaald op AllocDomain level, zodat er niet 25m celletjes buiten die selectie vallen.";
		parameter<UInt32> nr_cols           := ='uint32(/Geography/perGridsize/size_'+(ModelParameters/Advanced/AdminDomain_ref == '100m' ? '100m' : '25m')+'/nr_cols)';
	}
	
	unit<IPoint> AllocDomain := =ModelParameters/Advanced/AllocDomain_ref == '100m' ? 'Geography/rdc_100m' : 'Geography/rdc_25m' 
	, Descr = "Ruimtelijke resolutie waarop de allocatie plaatsvindt (keuze-eenheid). Dit kan 100m of 25m zijn."
	{
		parameter<String> name              := 'AllocDomain';
		attribute<Bool>   IsCompactedDomain := ./IsStudyArea;
		parameter<UInt32> nr_cols           := ='uint32(/Geography/perGridsize/size_'+(ModelParameters/Advanced/AllocDomain_ref == '100m' ? '100m' : '25m')+'/nr_cols)';
	}
	
	unit<uint64> CompactedAllocDomain := select_with_attr_by_org_rel(AllocDomain, AllocDomain/IsCompactedDomain), DialogType = "map", DialogData = "Per_AllocDomain"
	, Descr = "Subset van het AllocDomain, om rekentijd en geheugengebruik te beperken."
	{
		parameter<String>               name                          := 'CompactedAllocDomain';
		parameter<Units/Ha>             NrHaPerCell                   := AllocDomain/NrHaPerCell;
		attribute<.>                    Per_AllocDomain (AllocDomain) := invert(AllocDomain_rel), KeepData = "TRUE";
		
		attribute<AllocDomain>          AllocDomain_rel               := org_rel;
		attribute<AdminDomain>          AdminDomain_rel               := AllocDomain/AdminDomain_rel[AllocDomain_rel]; 
		attribute<CompactedAdminDomain> CompactedAdminDomain_rel      := rlookup(AdminDomain_rel, CompactedAdminDomain/AdminDomain_rel);
		attribute<.>                    CompactedAllocDomain_rel      := id(.);
	}
	
	unit<uint64> CompactedAdminDomain := select_with_attr_by_org_rel(AdminDomain, AdminDomain/IsCompactedDomain), DialogType = "map", DialogData = "Per_AdminDomain" 
	, Descr = "Subset van het AdminDomain, om rekentijd en geheugengebruik te beperken."
	{
		parameter<String>               name                          := 'CompactedAdminDomain';
		parameter<Units/Ha>             NrHaPerCell                   := AdminDomain/NrHaPerCell;
		attribute<.>                    Per_AdminDomain (AdminDomain) := invert(AdminDomain_rel), KeepData = "TRUE";
		attribute<AdminDomain>          AdminDomain_rel               := org_rel; 
		attribute<AllocDomain>          AllocDomain_rel               := AdminDomain/AllocDomain_rel[AdminDomain_rel]; 
		attribute<CompactedAllocDomain> CompactedAllocDomain_rel      := rlookup(AllocDomain_rel, CompactedAllocDomain/AllocDomain_rel), KeepData = "TRUE";
		attribute<.>                    CompactedAdminDomain_rel      := id(.);
		attribute<Geography/rdc_meter>  point                         := AdminDomain/point[org_rel];
	}
}